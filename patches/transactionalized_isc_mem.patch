diff -Naur -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/mem.c bind-modified/lib/isc/mem.c
--- bind-9.3.5-P2/lib/isc/mem.c	2007-11-26 17:45:51.000000000 -0600
+++ bind-modified/lib/isc/mem.c	2008-10-08 02:11:37.000000000 -0500
@@ -115,7 +115,6 @@
 struct isc_mem {
 	unsigned int		magic;
 	isc_ondestroy_t		ondestroy;
-	isc_mutex_t		lock;
 	isc_memalloc_t		memalloc;
 	isc_memfree_t		memfree;
 	void *			arg;
@@ -158,7 +157,6 @@
 struct isc_mempool {
 	/* always unlocked */
 	unsigned int	magic;		/* magic number */
-	isc_mutex_t    *lock;		/* optional lock */
 	isc_mem_t      *mctx;		/* our memory context */
 	/* locked via the memory context's lock */
 	ISC_LINK(isc_mempool_t)	link;	/* next pool in this mem context */
@@ -717,15 +715,6 @@
 	if (ctx == NULL)
 		return (ISC_R_NOMEMORY);
 
-	if (isc_mutex_init(&ctx->lock) != ISC_R_SUCCESS) {
-		UNEXPECTED_ERROR(__FILE__, __LINE__,
-				 "isc_mutex_init() %s",
-				 isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,
-						ISC_MSG_FAILED, "failed"));
-		(memfree)(arg, ctx);
-		return (ISC_R_UNEXPECTED);
-	}
-
 	if (init_max_size == 0U)
 		ctx->max_size = DEF_MAX_SIZE;
 	else
@@ -816,7 +805,6 @@
 		if (ctx->debuglist != NULL)
 			(ctx->memfree)(ctx->arg, ctx->debuglist);
 #endif /* ISC_MEM_TRACKLINES */
-		DESTROYLOCK(&ctx->lock);
 		(memfree)(arg, ctx);
 	}
 
@@ -890,7 +878,6 @@
 
 	ondest = ctx->ondestroy;
 
-	DESTROYLOCK(&ctx->lock);
 	(ctx->memfree)(ctx->arg, ctx);
 
 	isc_ondestroy_notify(&ondest, ctx);
@@ -901,9 +888,9 @@
 	REQUIRE(VALID_CONTEXT(source));
 	REQUIRE(targetp != NULL && *targetp == NULL);
 
-	LOCK(&source->lock);
-	source->references++;
-	UNLOCK(&source->lock);
+	__tm_atomic {
+		source->references++;
+	}
 
 	*targetp = source;
 }
@@ -917,12 +904,12 @@
 	ctx = *ctxp;
 	REQUIRE(VALID_CONTEXT(ctx));
 
-	LOCK(&ctx->lock);
-	INSIST(ctx->references > 0);
-	ctx->references--;
-	if (ctx->references == 0)
-		want_destroy = ISC_TRUE;
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		INSIST(ctx->references > 0);
+		ctx->references--;
+		if (ctx->references == 0)
+			want_destroy = ISC_TRUE;
+	}
 
 	if (want_destroy)
 		destroy(ctx);
@@ -956,22 +943,20 @@
 	 */
 	*ctxp = NULL;
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, ptr, size);
+		mem_putunlocked(ctx, ptr, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	mem_put(ctx, ptr, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, ptr, size);
+		mem_put(ctx, ptr, size);
+		mem_putstats(ctx, ptr, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
-	INSIST(ctx->references > 0);
-	ctx->references--;
-	if (ctx->references == 0)
-		want_destroy = ISC_TRUE;
-
-	UNLOCK(&ctx->lock);
+		DELETE_TRACE(ctx, ptr, size, file, line);
+		INSIST(ctx->references > 0);
+		ctx->references--;
+		if (ctx->references == 0)
+			want_destroy = ISC_TRUE;
+	}
 
 	if (want_destroy)
 		destroy(ctx);
@@ -990,14 +975,14 @@
 	ctx = *ctxp;
 	REQUIRE(VALID_CONTEXT(ctx));
 
-	LOCK(&ctx->lock);
+	__tm_atomic {
 #if ISC_MEM_TRACKLINES
-	if (ctx->references != 1)
-		print_active(ctx, stderr);
+		if (ctx->references != 1)
+			print_active(ctx, stderr);
 #endif
-	REQUIRE(ctx->references == 1);
-	ctx->references--;
-	UNLOCK(&ctx->lock);
+		REQUIRE(ctx->references == 1);
+		ctx->references--;
+	}
 
 	destroy(ctx);
 
@@ -1008,9 +993,9 @@
 isc_mem_ondestroy(isc_mem_t *ctx, isc_task_t *task, isc_event_t **event) {
 	isc_result_t res;
 
-	LOCK(&ctx->lock);
-	res = isc_ondestroy_register(&ctx->ondestroy, task, event);
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		res = isc_ondestroy_register(&ctx->ondestroy, task, event);
+	}
 
 	return (res);
 }
@@ -1023,30 +1008,29 @@
 
 	REQUIRE(VALID_CONTEXT(ctx));
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	ptr = mem_getunlocked(ctx, size);
+		ptr = mem_getunlocked(ctx, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	ptr = mem_get(ctx, size);
-	LOCK(&ctx->lock);
-	if (ptr != NULL)
-		mem_getstats(ctx, size);
+		ptr = mem_get(ctx, size);
+		if (ptr != NULL)
+			mem_getstats(ctx, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	ADD_TRACE(ctx, ptr, size, file, line);
-	if (ctx->hi_water != 0U && !ctx->hi_called &&
-	    ctx->inuse > ctx->hi_water) {
-		ctx->hi_called = ISC_TRUE;
-		call_water = ISC_TRUE;
-	}
-	if (ctx->inuse > ctx->maxinuse) {
-		ctx->maxinuse = ctx->inuse;
-		if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
-		    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
-			fprintf(stderr, "maxinuse = %lu\n",
-				(unsigned long)ctx->inuse);
+		ADD_TRACE(ctx, ptr, size, file, line);
+		if (ctx->hi_water != 0U && !ctx->hi_called &&
+		    ctx->inuse > ctx->hi_water) {
+			ctx->hi_called = ISC_TRUE;
+			call_water = ISC_TRUE;
+		}
+		if (ctx->inuse > ctx->maxinuse) {
+			ctx->maxinuse = ctx->inuse;
+			if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
+			    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
+				fprintf(stderr, "maxinuse = %lu\n",
+					(unsigned long)ctx->inuse);
+		}
 	}
-	UNLOCK(&ctx->lock);
 
 	if (call_water)
 		(ctx->water)(ctx->water_arg, ISC_MEM_HIWATER);
@@ -1062,30 +1046,29 @@
 	REQUIRE(VALID_CONTEXT(ctx));
 	REQUIRE(ptr != NULL);
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, ptr, size);
+		mem_putunlocked(ctx, ptr, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	mem_put(ctx, ptr, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, ptr, size);
+		mem_put(ctx, ptr, size);
+		mem_putstats(ctx, ptr, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
+		DELETE_TRACE(ctx, ptr, size, file, line);
 
-	/*
-	 * The check against ctx->lo_water == 0 is for the condition
-	 * when the context was pushed over hi_water but then had
-	 * isc_mem_setwater() called with 0 for hi_water and lo_water.
-	 */
-	if (ctx->hi_called && 
-	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
-		ctx->hi_called = ISC_FALSE;
+		/*
+		 * The check against ctx->lo_water == 0 is for the condition
+		 * when the context was pushed over hi_water but then had
+		 * isc_mem_setwater() called with 0 for hi_water and lo_water.
+		 */
+		if (ctx->hi_called && 
+		    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
+			ctx->hi_called = ISC_FALSE;
 
-		if (ctx->water != NULL)
-			call_water = ISC_TRUE;
+			if (ctx->water != NULL)
+				call_water = ISC_TRUE;
+		}
 	}
-	UNLOCK(&ctx->lock);
 
 	if (call_water)
 		(ctx->water)(ctx->water_arg, ISC_MEM_LOWATER);
@@ -1142,69 +1125,69 @@
 	const isc_mempool_t *pool;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
+	__tm_atomic {
 
-	for (i = 0; i <= ctx->max_size; i++) {
-		s = &ctx->stats[i];
+		for (i = 0; i <= ctx->max_size; i++) {
+			s = &ctx->stats[i];
 
-		if (s->totalgets == 0U && s->gets == 0U)
-			continue;
-		fprintf(out, "%s%5lu: %11lu gets, %11lu rem",
-			(i == ctx->max_size) ? ">=" : "  ",
-			(unsigned long) i, s->totalgets, s->gets);
+			if (s->totalgets == 0U && s->gets == 0U)
+				continue;
+			fprintf(out, "%s%5lu: %11lu gets, %11lu rem",
+				(i == ctx->max_size) ? ">=" : "  ",
+				(unsigned long) i, s->totalgets, s->gets);
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		if (s->blocks != 0 || s->freefrags != 0)
-			fprintf(out, " (%lu bl, %lu ff)",
-				s->blocks, s->freefrags);
+			if (s->blocks != 0 || s->freefrags != 0)
+				fprintf(out, " (%lu bl, %lu ff)",
+					s->blocks, s->freefrags);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		fputc('\n', out);
-	}
+			fputc('\n', out);
+		}
 
-	/*
-	 * Note that since a pool can be locked now, these stats might be
-	 * somewhat off if the pool is in active use at the time the stats
-	 * are dumped.  The link fields are protected by the isc_mem_t's
-	 * lock, however, so walking this list and extracting integers from
-	 * stats fields is always safe.
-	 */
-	pool = ISC_LIST_HEAD(ctx->pools);
-	if (pool != NULL) {
-		fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-					    ISC_MSG_POOLSTATS,
-					    "[Pool statistics]\n"));
-		fprintf(out, "%15s %10s %10s %10s %10s %10s %10s %10s %1s\n",
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLNAME, "name"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLSIZE, "size"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLMAXALLOC, "maxalloc"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLALLOCATED, "allocated"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFREECOUNT, "freecount"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFREEMAX, "freemax"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFILLCOUNT, "fillcount"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLGETS, "gets"),
-			"L");
-	}
-	while (pool != NULL) {
-		fprintf(out, "%15s %10lu %10u %10u %10u %10u %10u %10u %s\n",
-			pool->name, (unsigned long) pool->size, pool->maxalloc,
-			pool->allocated, pool->freecount, pool->freemax,
-			pool->fillcount, pool->gets,
-			(pool->lock == NULL ? "N" : "Y"));
-		pool = ISC_LIST_NEXT(pool, link);
-	}
+		/*
+		 * Note that since a pool can be locked now, these stats might be
+		 * somewhat off if the pool is in active use at the time the stats
+		 * are dumped.  The link fields are protected by the isc_mem_t's
+		 * lock, however, so walking this list and extracting integers from
+		 * stats fields is always safe.
+		 */
+		pool = ISC_LIST_HEAD(ctx->pools);
+		if (pool != NULL) {
+			fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+						    ISC_MSG_POOLSTATS,
+						    "[Pool statistics]\n"));
+			fprintf(out, "%15s %10s %10s %10s %10s %10s %10s %10s %1s\n",
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLNAME, "name"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLSIZE, "size"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLMAXALLOC, "maxalloc"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLALLOCATED, "allocated"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFREECOUNT, "freecount"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFREEMAX, "freemax"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFILLCOUNT, "fillcount"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLGETS, "gets"),
+				"L");
+		}
+		while (pool != NULL) {
+			fprintf(out, "%15s %10lu %10u %10u %10u %10u %10u %10u %s\n",
+				pool->name, (unsigned long) pool->size, pool->maxalloc,
+				pool->allocated, pool->freecount, pool->freemax,
+				pool->fillcount, pool->gets,
+				"Y");
+			pool = ISC_LIST_NEXT(pool, link);
+		}
 
 #if ISC_MEM_TRACKLINES
-	print_active(ctx, out);
+		print_active(ctx, out);
 #endif
 
-	UNLOCK(&ctx->lock);
+	}
 }
 
 /*
@@ -1234,21 +1217,19 @@
 
 	REQUIRE(VALID_CONTEXT(ctx));
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	si = isc__mem_allocateunlocked(ctx, size);
+		si = isc__mem_allocateunlocked(ctx, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	si = isc__mem_allocateunlocked(ctx, size);
-	LOCK(&ctx->lock);
-	if (si != NULL)
-		mem_getstats(ctx, si[-1].u.size);
+		si = isc__mem_allocateunlocked(ctx, size);
+		if (si != NULL)
+			mem_getstats(ctx, si[-1].u.size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
 #if ISC_MEM_TRACKLINES
-	ADD_TRACE(ctx, si, si[-1].u.size, file, line);
+		ADD_TRACE(ctx, si, si[-1].u.size, file, line);
 #endif
-
-	UNLOCK(&ctx->lock);
+	}
 
 	return (si);
 }
@@ -1264,18 +1245,16 @@
 	si = &(((size_info *)ptr)[-1]);
 	size = si->u.size;
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, si, size);
+		mem_putunlocked(ctx, si, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	mem_put(ctx, si, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, si, size);
+		mem_put(ctx, si, size);
+		mem_putstats(ctx, si, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
+		DELETE_TRACE(ctx, ptr, size, file, line);
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
-
-	UNLOCK(&ctx->lock);
+	}
 }
 
 
@@ -1304,11 +1283,9 @@
 void
 isc_mem_setdestroycheck(isc_mem_t *ctx, isc_boolean_t flag) {
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	ctx->checkfree = flag;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		ctx->checkfree = flag;
+	}
 }
 
 /*
@@ -1318,11 +1295,9 @@
 void
 isc_mem_setquota(isc_mem_t *ctx, size_t quota) {
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	ctx->quota = quota;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		ctx->quota = quota;
+	}
 }
 
 size_t
@@ -1330,11 +1305,9 @@
 	size_t quota;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	quota = ctx->quota;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		quota = ctx->quota;
+	}
 
 	return (quota);
 }
@@ -1344,11 +1317,9 @@
 	size_t inuse;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	inuse = ctx->inuse;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		inuse = ctx->inuse;
+	}
 
 	return (inuse);
 }
@@ -1364,28 +1335,28 @@
 	REQUIRE(VALID_CONTEXT(ctx));
 	REQUIRE(hiwater >= lowater);
 
-	LOCK(&ctx->lock);
-	oldwater = ctx->water;
-	oldwater_arg = ctx->water_arg;
-	if (water == NULL) {
-		callwater = ctx->hi_called;
-		ctx->water = NULL;
-		ctx->water_arg = NULL;
-		ctx->hi_water = 0;
-		ctx->lo_water = 0;
-		ctx->hi_called = ISC_FALSE;
-	} else {
-		if (ctx->hi_called &&
-		    (ctx->water != water || ctx->water_arg != water_arg ||
-		     ctx->inuse < lowater || lowater == 0U))
-			callwater = ISC_TRUE;
-		ctx->water = water;
-		ctx->water_arg = water_arg;
-		ctx->hi_water = hiwater;
-		ctx->lo_water = lowater;
-		ctx->hi_called = ISC_FALSE;
+	__tm_atomic {
+		oldwater = ctx->water;
+		oldwater_arg = ctx->water_arg;
+		if (water == NULL) {
+			callwater = ctx->hi_called;
+			ctx->water = NULL;
+			ctx->water_arg = NULL;
+			ctx->hi_water = 0;
+			ctx->lo_water = 0;
+			ctx->hi_called = ISC_FALSE;
+		} else {
+			if (ctx->hi_called &&
+			    (ctx->water != water || ctx->water_arg != water_arg ||
+			     ctx->inuse < lowater || lowater == 0U))
+				callwater = ISC_TRUE;
+			ctx->water = water;
+			ctx->water_arg = water_arg;
+			ctx->hi_water = hiwater;
+			ctx->lo_water = lowater;
+			ctx->hi_called = ISC_FALSE;
+		}
 	}
-	UNLOCK(&ctx->lock);
 
 	if (callwater && oldwater != NULL)
 		(oldwater)(oldwater_arg, ISC_MEM_LOWATER);
@@ -1412,7 +1383,6 @@
 		return (ISC_R_NOMEMORY);
 
 	mpctx->magic = MEMPOOL_MAGIC;
-	mpctx->lock = NULL;
 	mpctx->mctx = mctx;
 	mpctx->size = size;
 	mpctx->maxalloc = UINT_MAX;
@@ -1428,9 +1398,9 @@
 
 	*mpctxp = mpctx;
 
-	LOCK(&mctx->lock);
-	ISC_LIST_INITANDAPPEND(mctx->pools, mpctx, link);
-	UNLOCK(&mctx->lock);
+	__tm_atomic {
+		ISC_LIST_INITANDAPPEND(mctx->pools, mpctx, link);
+	}
 
 	return (ISC_R_SUCCESS);
 }
@@ -1440,14 +1410,10 @@
 	REQUIRE(name != NULL);
 
 #if ISC_MEMPOOL_NAMES
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	strncpy(mpctx->name, name, sizeof(mpctx->name) - 1);
-	mpctx->name[sizeof(mpctx->name) - 1] = '\0';
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		strncpy(mpctx->name, name, sizeof(mpctx->name) - 1);
+		mpctx->name[sizeof(mpctx->name) - 1] = '\0';
+	}
 #else
 	UNUSED(mpctx);
 	UNUSED(name);
@@ -1458,7 +1424,6 @@
 isc_mempool_destroy(isc_mempool_t **mpctxp) {
 	isc_mempool_t *mpctx;
 	isc_mem_t *mctx;
-	isc_mutex_t *lock;
 	element *item;
 
 	REQUIRE(mpctxp != NULL);
@@ -1475,43 +1440,38 @@
 
 	mctx = mpctx->mctx;
 
-	lock = mpctx->lock;
+	__tm_atomic {
 
-	if (lock != NULL)
-		LOCK(lock);
-
-	/*
-	 * Return any items on the free list
-	 */
-	LOCK(&mctx->lock);
-	while (mpctx->items != NULL) {
-		INSIST(mpctx->freecount > 0);
-		mpctx->freecount--;
-		item = mpctx->items;
-		mpctx->items = item->next;
+		/*
+		 * Return any items on the free list
+		 */
+		__tm_atomic {
+			while (mpctx->items != NULL) {
+				INSIST(mpctx->freecount > 0);
+				mpctx->freecount--;
+				item = mpctx->items;
+				mpctx->items = item->next;
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		mem_putunlocked(mctx, item, mpctx->size);
+				mem_putunlocked(mctx, item, mpctx->size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		mem_put(mctx, item, mpctx->size);
-		mem_putstats(mctx, item, mpctx->size);
+				mem_put(mctx, item, mpctx->size);
+				mem_putstats(mctx, item, mpctx->size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-	}
-	UNLOCK(&mctx->lock);
-
-	/*
-	 * Remove our linked list entry from the memory context.
-	 */
-	LOCK(&mctx->lock);
-	ISC_LIST_UNLINK(mctx->pools, mpctx, link);
-	UNLOCK(&mctx->lock);
+			}
+		}
 
-	mpctx->magic = 0;
+		/*
+		 * Remove our linked list entry from the memory context.
+		 */
+		__tm_atomic {
+			ISC_LIST_UNLINK(mctx->pools, mpctx, link);
+		}
 
-	isc_mem_put(mpctx->mctx, mpctx, sizeof(isc_mempool_t));
+		mpctx->magic = 0;
 
-	if (lock != NULL)
-		UNLOCK(lock);
+		isc_mem_put(mpctx->mctx, mpctx, sizeof(isc_mempool_t));
+	}
 
 	*mpctxp = NULL;
 }
@@ -1519,10 +1479,10 @@
 void
 isc_mempool_associatelock(isc_mempool_t *mpctx, isc_mutex_t *lock) {
 	REQUIRE(VALID_MEMPOOL(mpctx));
-	REQUIRE(mpctx->lock == NULL);
+	// REQUIRE(mpctx->lock == NULL);
 	REQUIRE(lock != NULL);
 
-	mpctx->lock = lock;
+	// mpctx->lock = lock;
 }
 
 void *
@@ -1535,72 +1495,70 @@
 
 	mctx = mpctx->mctx;
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	/*
-	 * Don't let the caller go over quota
-	 */
-	if (mpctx->allocated >= mpctx->maxalloc) {
-		item = NULL;
-		goto out;
-	}
+	__tm_atomic {
 
-	/*
-	 * if we have a free list item, return the first here
-	 */
-	item = mpctx->items;
-	if (item != NULL) {
-		mpctx->items = item->next;
-		INSIST(mpctx->freecount > 0);
-		mpctx->freecount--;
-		mpctx->gets++;
-		mpctx->allocated++;
-		goto out;
-	}
-
-	/*
-	 * We need to dip into the well.  Lock the memory context here and
-	 * fill up our free list.
-	 */
-	LOCK(&mctx->lock);
-	for (i = 0; i < mpctx->fillcount; i++) {
+		/*
+		 * Don't let the caller go over quota
+		 */
+		if (mpctx->allocated >= mpctx->maxalloc) {
+			item = NULL;
+		}
+		else
+		{
+			/*
+			 * if we have a free list item, return the first here
+			 */
+			item = mpctx->items;
+			if (item != NULL) {
+				mpctx->items = item->next;
+				INSIST(mpctx->freecount > 0);
+				mpctx->freecount--;
+				mpctx->gets++;
+				mpctx->allocated++;
+			}
+			else
+			{
+				/*
+				 * We need to dip into the well.  Lock the memory context here and
+				 * fill up our free list.
+				 */
+				__tm_atomic {
+					for (i = 0; i < mpctx->fillcount; i++) {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		item = mem_getunlocked(mctx, mpctx->size);
+						item = mem_getunlocked(mctx, mpctx->size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		item = mem_get(mctx, mpctx->size);
-		if (item != NULL)
-			mem_getstats(mctx, mpctx->size);
+						item = mem_get(mctx, mpctx->size);
+						if (item != NULL)
+							mem_getstats(mctx, mpctx->size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		if (item == NULL)
-			break;
-		item->next = mpctx->items;
-		mpctx->items = item;
-		mpctx->freecount++;
-	}
-	UNLOCK(&mctx->lock);
+						if (item == NULL)
+							break;
+						item->next = mpctx->items;
+						mpctx->items = item;
+						mpctx->freecount++;
+					}
+				}
 
-	/*
-	 * If we didn't get any items, return NULL.
-	 */
-	item = mpctx->items;
-	if (item == NULL)
-		goto out;
-
-	mpctx->items = item->next;
-	mpctx->freecount--;
-	mpctx->gets++;
-	mpctx->allocated++;
-
- out:
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+				/*
+				 * If we didn't get any items, return NULL.
+				 */
+				item = mpctx->items;
+				if (item != NULL)
+				{
+					mpctx->items = item->next;
+					mpctx->freecount--;
+					mpctx->gets++;
+					mpctx->allocated++;
+				}
+			}
+		}
+	}
 
 #if ISC_MEM_TRACKLINES
 	if (item != NULL) {
-		LOCK(&mctx->lock);
-		ADD_TRACE(mctx, item, mpctx->size, file, line);
-		UNLOCK(&mctx->lock);
+		__tm_atomic {
+			ADD_TRACE(mctx, item, mpctx->size, file, line);
+		}
 	}
 #endif /* ISC_MEM_TRACKLINES */
 
@@ -1617,47 +1575,41 @@
 
 	mctx = mpctx->mctx;
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	INSIST(mpctx->allocated > 0);
-	mpctx->allocated--;
+	__tm_atomic {
+		INSIST(mpctx->allocated > 0);
+		mpctx->allocated--;
 
 #if ISC_MEM_TRACKLINES
-	LOCK(&mctx->lock);
-	DELETE_TRACE(mctx, mem, mpctx->size, file, line);
-	UNLOCK(&mctx->lock);
+		__tm_atomic {
+			DELETE_TRACE(mctx, mem, mpctx->size, file, line);
+		}
 #endif /* ISC_MEM_TRACKLINES */
 
-	/*
-	 * If our free list is full, return this to the mctx directly.
-	 */
-	if (mpctx->freecount >= mpctx->freemax) {
+		/*
+		 * If our free list is full, return this to the mctx directly.
+		 */
+		if (mpctx->freecount >= mpctx->freemax) {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		LOCK(&mctx->lock);
-		mem_putunlocked(mctx, mem, mpctx->size);
-		UNLOCK(&mctx->lock);
+			__tm_atomic {
+				mem_putunlocked(mctx, mem, mpctx->size);
+			}
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		mem_put(mctx, mem, mpctx->size);
-		LOCK(&mctx->lock);
-		mem_putstats(mctx, mem, mpctx->size);
-		UNLOCK(&mctx->lock);
+			mem_put(mctx, mem, mpctx->size);
+			__tm_atomic {
+				mem_putstats(mctx, mem, mpctx->size);
+			}
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		if (mpctx->lock != NULL)
-			UNLOCK(mpctx->lock);
-		return;
+		}
+		else {
+			/*
+			 * Otherwise, attach it to our free list and bump the counter.
+			 */
+			mpctx->freecount++;
+			item = (element *)mem;
+			item->next = mpctx->items;
+			mpctx->items = item;
+		}
 	}
-
-	/*
-	 * Otherwise, attach it to our free list and bump the counter.
-	 */
-	mpctx->freecount++;
-	item = (element *)mem;
-	item->next = mpctx->items;
-	mpctx->items = item;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
 }
 
 /*
@@ -1668,13 +1620,9 @@
 isc_mempool_setfreemax(isc_mempool_t *mpctx, unsigned int limit) {
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->freemax = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		mpctx->freemax = limit;
+	}
 }
 
 unsigned int
@@ -1683,13 +1631,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	freemax = mpctx->freemax;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		freemax = mpctx->freemax;
+	}
 
 	return (freemax);
 }
@@ -1700,13 +1644,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	freecount = mpctx->freecount;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		freecount = mpctx->freecount;
+	}
 
 	return (freecount);
 }
@@ -1717,13 +1657,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->maxalloc = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		mpctx->maxalloc = limit;
+	}
 }
 
 unsigned int
@@ -1732,13 +1668,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	maxalloc = mpctx->maxalloc;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		maxalloc = mpctx->maxalloc;
+	}
 
 	return (maxalloc);
 }
@@ -1749,13 +1681,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	allocated = mpctx->allocated;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		allocated = mpctx->allocated;
+	}
 
 	return (allocated);
 }
@@ -1765,13 +1693,9 @@
 	REQUIRE(limit > 0);
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->fillcount = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		mpctx->fillcount = limit;
+	}
 }
 
 unsigned int
@@ -1780,13 +1704,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	fillcount = mpctx->fillcount;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		fillcount = mpctx->fillcount;
+	}
 
 	return (fillcount);
 }
