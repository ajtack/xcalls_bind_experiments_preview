diff -Naur -x '._*' -x 'Makefile' -x '*.i' -x '*~' -x 'make' -x '*.log' -x 'doc' -x 'contrib' -x 'tests' -x 'config.h' -x 'config.status' -x 'isc-config.h' -x '*.kdev*' -x 'platform.h' -x 'netdb.h' -x 'Doxyfile' -x 'port_*.h' old/bin/named/main.c bind-9.3.5-P2/bin/named/main.c
--- old/bin/named/main.c	2006-11-10 12:51:06.000000000 -0600
+++ bind-9.3.5-P2/bin/named/main.c	2008-10-28 16:20:54.000000000 -0500
@@ -66,6 +66,8 @@
 #include <named/ns_smf_globals.h>
 #endif
 
+#include <txc.h>
+
 /*
  * Include header files for database drivers here.
  */
@@ -781,6 +783,9 @@
 	char *instance = NULL;
 #endif
 
+	txc_global_init();
+	txc_thread_init();
+
 	/*
 	 * Record version in core image.
 	 * strings named.core | grep "named version:"
diff -Naur -x '._*' -x 'Makefile' -x '*.i' -x '*~' -x 'make' -x '*.log' -x 'doc' -x 'contrib' -x 'tests' -x 'config.h' -x 'config.status' -x 'isc-config.h' -x '*.kdev*' -x 'platform.h' -x 'netdb.h' -x 'Doxyfile' -x 'port_*.h' old/lib/isc/task.c bind-9.3.5-P2/lib/isc/task.c
--- old/lib/isc/task.c	2004-10-14 19:45:45.000000000 -0500
+++ bind-9.3.5-P2/lib/isc/task.c	2008-10-28 21:53:24.000000000 -0500
@@ -38,6 +38,7 @@
 #include <isc/task.h>
 #include <isc/thread.h>
 #include <isc/util.h>
+#include <txc.h>
 
 #ifndef ISC_PLATFORM_USETHREADS
 #include "task_p.h"
@@ -1004,6 +1005,7 @@
 WINAPI
 #endif
 run(void *uap) {
+	txc_thread_init();
 	isc_taskmgr_t *manager = uap;
 
 	XTHREADTRACE(isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,
diff -Naur -x '._*' -x 'Makefile' -x '*.i' -x '*~' -x 'make' -x '*.log' -x 'doc' -x 'contrib' -x 'tests' -x 'config.h' -x 'config.status' -x 'isc-config.h' -x '*.kdev*' -x 'platform.h' -x 'netdb.h' -x 'Doxyfile' -x 'port_*.h' old/lib/isc/unix/socket.c bind-9.3.5-P2/lib/isc/unix/socket.c
--- old/lib/isc/unix/socket.c	2008-07-28 23:43:57.000000000 -0500
+++ bind-9.3.5-P2/lib/isc/unix/socket.c	2008-10-28 16:53:19.000000000 -0500
@@ -51,6 +51,7 @@
 #include <isc/task.h>
 #include <isc/thread.h>
 #include <isc/util.h>
+#include <txc.h>
 
 #include "errno2result.h"
 
@@ -2333,6 +2334,8 @@
 	int maxfd;
 	char strbuf[ISC_STRERRORSIZE];
 
+	txc_thread_init();
+
 	/*
 	 * Get the control fd here.  This will never change.
 	 */
diff -Naur -x '._*' -x 'Makefile' -x '*.i' -x '*~' -x 'make' -x '*.log' -x 'doc' -x 'contrib' -x 'tests' -x 'config.h' -x 'config.status' -x 'isc-config.h' -x '*.kdev*' -x 'platform.h' -x 'netdb.h' -x 'Doxyfile' -x 'port_*.h' old/lib/isc/timer.c bind-9.3.5-P2/lib/isc/timer.c
--- old/lib/isc/timer.c	2008-07-29 13:34:29.000000000 -0500
+++ bind-9.3.5-P2/lib/isc/timer.c	2008-10-28 16:50:19.000000000 -0500
@@ -31,6 +31,7 @@
 #include <isc/time.h>
 #include <isc/timer.h>
 #include <isc/util.h>
+#include <txc.h>
 
 #ifndef ISC_PLATFORM_USETHREADS
 #include "timer_p.h"
@@ -703,6 +704,8 @@
 	isc_time_t now;
 	isc_result_t result;
 
+	txc_thread_init();
+
 	LOCK(&manager->lock);
 	while (!manager->done) {
 		TIME_NOW(&now);
diff -Naur -x '._*' -x 'Makefile' -x '*.i' -x '*~' -x 'make' -x '*.log' -x 'doc' -x 'contrib' -x 'tests' -x 'config.h' -x 'config.status' -x 'isc-config.h' -x '*.kdev*' -x 'platform.h' -x 'netdb.h' -x 'Doxyfile' -x 'port_*.h' bind-9.3.5-P2/lib/isc/pthreads/thread.c changed/lib/isc/pthreads/thread.c
--- bind-9.3.5-P2/lib/isc/pthreads/thread.c	2004-12-04 00:50:03.000000000 -0600
+++ changed/lib/isc/pthreads/thread.c	2008-10-28 12:02:05.000000000 -0500
@@ -21,6 +21,7 @@
 
 #include <isc/thread.h>
 #include <isc/util.h>
+#include <txc.h>
 
 #ifndef THREAD_MINSTACKSIZE
 #define THREAD_MINSTACKSIZE		(64U * 1024)
@@ -60,6 +61,7 @@
 		return (ISC_R_UNEXPECTED);
 
 	pthread_attr_destroy(&attr);
+	txc_thread_init();
 
 	return (ISC_R_SUCCESS);
 }
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/bin/check/check-tool.c changed/bin/check/check-tool.c
--- bind-9.3.5-P2/bin/check/check-tool.c	2007-09-13 00:18:07.000000000 -0500
+++ changed/bin/check/check-tool.c	2008-10-28 00:28:05.000000000 -0500
@@ -62,7 +62,7 @@
 	RUNTIME_CHECK(isc_log_create(mctx, &log, &logconfig) == ISC_R_SUCCESS);
 	isc_log_setcontext(log);
 
-	destination.file.stream = stdout;
+	destination.file.descriptor = 1;
 	destination.file.name = NULL;
 	destination.file.versions = ISC_LOG_ROLLNEVER;
 	destination.file.maximum_size = 0;
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/bin/dnssec/dnssectool.c changed/bin/dnssec/dnssectool.c
--- bind-9.3.5-P2/bin/dnssec/dnssectool.c	2005-07-01 21:42:43.000000000 -0500
+++ changed/bin/dnssec/dnssectool.c	2008-10-28 00:28:15.000000000 -0500
@@ -176,7 +176,7 @@
 	 *  - the program name and logging level are printed
 	 *  - no time stamp is printed
 	 */
-	destination.file.stream = stderr;
+	destination.file.descriptor = 2;
 	destination.file.name = NULL;
 	destination.file.versions = ISC_LOG_ROLLNEVER;
 	destination.file.maximum_size = 0;
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/bin/named/log.c changed/bin/named/log.c
--- bind-9.3.5-P2/bin/named/log.c	2007-08-28 02:19:08.000000000 -0500
+++ changed/bin/named/log.c	2008-10-28 00:24:27.000000000 -0500
@@ -117,7 +117,7 @@
 	 * instead, unless the the -g option was given.
 	 */
 	if (! ns_g_logstderr) {
-		destination.file.stream = NULL;
+		destination.file.descriptor = 0;
 		destination.file.name = "named.run";
 		destination.file.versions = ISC_LOG_ROLLNEVER;
 		destination.file.maximum_size = 0;
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/bin/named/logconf.c changed/bin/named/logconf.c
--- bind-9.3.5-P2/bin/named/logconf.c	2007-08-28 02:19:08.000000000 -0500
+++ changed/bin/named/logconf.c	2008-10-28 00:25:16.000000000 -0500
@@ -148,7 +148,7 @@
 		    cfg_obj_isuint64(sizeobj) &&
 		    cfg_obj_asuint64(sizeobj) < ISC_OFFSET_MAXIMUM)
 			size = (isc_offset_t)cfg_obj_asuint64(sizeobj);
-		dest.file.stream = NULL;
+		dest.file.descriptor = 0;
 		dest.file.name = cfg_obj_asstring(pathobj);
 		dest.file.versions = versions;
 		dest.file.maximum_size = size;
@@ -165,7 +165,7 @@
 		dest.facility = facility;
 	} else if (stderrobj != NULL) {
 		type = ISC_LOG_TOFILEDESC;
-		dest.file.stream = stderr;
+		dest.file.descriptor = 2;  // stderr is FD #2
 		dest.file.name = NULL;
 		dest.file.versions = ISC_LOG_ROLLNEVER;
 		dest.file.maximum_size = 0;
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/bin/rndc/rndc.c changed/bin/rndc/rndc.c
--- bind-9.3.5-P2/bin/rndc/rndc.c	2006-08-03 22:03:08.000000000 -0500
+++ changed/bin/rndc/rndc.c	2008-10-28 00:26:32.000000000 -0500
@@ -618,7 +618,7 @@
 	DO("create logging context", isc_log_create(mctx, &log, &logconfig));
 	isc_log_setcontext(log);
 	DO("setting log tag", isc_log_settag(logconfig, progname));
-	logdest.file.stream = stderr;
+	logdest.file.descriptor = 2;
 	logdest.file.name = NULL;
 	logdest.file.versions = ISC_LOG_ROLLNEVER;
 	logdest.file.maximum_size = 0;
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/error.c changed/lib/isc/error.c
--- bind-9.3.5-P2/lib/isc/error.c	2004-03-06 02:14:28.000000000 -0600
+++ changed/lib/isc/error.c	2008-10-27 23:50:37.000000000 -0500
@@ -61,6 +61,7 @@
 	va_end(args);
 }
 
+TM_WAIVER
 void
 isc_error_fatal(const char *file, int line, const char *format, ...) {
 	va_list args;
@@ -71,6 +72,7 @@
 	abort();
 }
 
+TM_CALLABLE
 void
 isc_error_runtimecheck(const char *file, int line, const char *expression) {
 	isc_error_fatal(file, line, "RUNTIME_CHECK(%s) %s", expression,
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/include/isc/error.h changed/lib/isc/include/isc/error.h
--- bind-9.3.5-P2/lib/isc/include/isc/error.h	2004-03-06 02:14:40.000000000 -0600
+++ changed/lib/isc/include/isc/error.h	2008-10-27 23:50:29.000000000 -0500
@@ -39,10 +39,12 @@
 isc_error_unexpected(const char *, int, const char *, ...)
      ISC_FORMAT_PRINTF(3, 4);
 
+TM_WAIVER
 void
 isc_error_fatal(const char *, int, const char *, ...)
      ISC_FORMAT_PRINTF(3, 4);
 
+TM_CALLABLE
 void
 isc_error_runtimecheck(const char *, int, const char *);
 
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/include/isc/log.h changed/lib/isc/include/isc/log.h
--- bind-9.3.5-P2/lib/isc/include/isc/log.h	2007-08-28 02:19:15.000000000 -0500
+++ changed/lib/isc/include/isc/log.h	2008-10-27 09:30:01.000000000 -0500
@@ -100,7 +100,7 @@
  * Setting maximum_size to zero implies no maximum.
  */
 typedef struct isc_logfile {
-	FILE *stream;		/* Initialized to NULL for ISC_LOG_TOFILE. */
+	int descriptor;		/* Initialized to 0 for ISC_LOG_TOFILE. */
 	const char *name;	/* NULL for ISC_LOG_TOFILEDESC. */
 	int versions;	/* >= 0, ISC_LOG_ROLLNEVER, ISC_LOG_ROLLINFINITE. */
 	/*
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/include/isc/mem.h changed/lib/isc/include/isc/mem.h
--- bind-9.3.5-P2/lib/isc/include/isc/mem.h	2007-08-28 02:19:15.000000000 -0500
+++ changed/lib/isc/include/isc/mem.h	2008-10-27 12:16:32.000000000 -0500
@@ -429,11 +429,13 @@
 /*
  * Pseudo-private functions for use via macros.  Do not call directly.
  */
+TM_CALLABLE
 void *		
 isc__mem_get(isc_mem_t *, size_t _ISC_MEM_FLARG);
 void 		
 isc__mem_putanddetach(isc_mem_t **, void *,
 				      size_t _ISC_MEM_FLARG);
+TM_CALLABLE
 void 		
 isc__mem_put(isc_mem_t *, void *, size_t _ISC_MEM_FLARG);
 void *		
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/include/isc/msgcat.h changed/lib/isc/include/isc/msgcat.h
--- bind-9.3.5-P2/lib/isc/include/isc/msgcat.h	2004-03-06 02:14:44.000000000 -0600
+++ changed/lib/isc/include/isc/msgcat.h	2008-10-27 12:13:52.000000000 -0500
@@ -109,6 +109,7 @@
  *	*msgcatp == NULL
  */
 
+TM_WAIVER
 const char *
 isc_msgcat_get(isc_msgcat_t *msgcat, int set, int message,
 	       const char *default_text);
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/include/isc/result.h changed/lib/isc/include/isc/result.h
--- bind-9.3.5-P2/lib/isc/include/isc/result.h	2007-08-28 02:19:15.000000000 -0500
+++ changed/lib/isc/include/isc/result.h	2008-10-27 23:34:16.000000000 -0500
@@ -91,6 +91,7 @@
 
 ISC_LANG_BEGINDECLS
 
+TM_CALLABLE
 const char *
 isc_result_totext(isc_result_t);
 /*
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/log.c changed/lib/isc/log.c
--- bind-9.3.5-P2/lib/isc/log.c	2006-03-01 18:37:20.000000000 -0600
+++ changed/lib/isc/log.c	2008-10-28 00:18:57.000000000 -0500
@@ -22,6 +22,7 @@
 #include <config.h>
 
 #include <errno.h>
+#include <fcntl.h>
 #include <stdlib.h>
 #include <limits.h>
 #include <time.h>
@@ -41,6 +42,8 @@
 #include <isc/time.h>
 #include <isc/util.h>
 
+#include <txc.h>
+
 #define LCTX_MAGIC		ISC_MAGIC('L', 'c', 't', 'x')
 #define VALID_CONTEXT(lctx)	ISC_MAGIC_VALID(lctx, LCTX_MAGIC)
 
@@ -149,7 +152,6 @@
 	isc_logmodule_t *		modules;
 	unsigned int			module_count;
 	int				debug_level;
-	isc_mutex_t			lock;
 	/* Locked by isc_log lock. */
 	isc_logconfig_t * 		logconfig;
 	char 				buffer[LOG_BUFFER_SIZE];
@@ -228,9 +230,11 @@
 static isc_result_t
 sync_channellist(isc_logconfig_t *lcfg);
 
+TM_CALLABLE
 static isc_result_t
 greatest_version(isc_logchannel_t *channel, int *greatest);
 
+TM_CALLABLE
 static isc_result_t
 roll_log(isc_logchannel_t *channel);
 
@@ -247,7 +251,7 @@
 
 #define FACILITY(channel)	 (channel->destination.facility)
 #define FILE_NAME(channel)	 (channel->destination.file.name)
-#define FILE_STREAM(channel)	 (channel->destination.file.stream)
+#define FILE_DESCRIPTOR(channel)	 (channel->destination.file.descriptor)
 #define FILE_VERSIONS(channel)	 (channel->destination.file.versions)
 #define FILE_MAXSIZE(channel)	 (channel->destination.file.maximum_size)
 #define FILE_MAXREACHED(channel) (channel->destination.file.maximum_reached)
@@ -280,8 +284,6 @@
 
 		ISC_LIST_INIT(lctx->messages);
 
-		RUNTIME_CHECK(isc_mutex_init(&lctx->lock) == ISC_R_SUCCESS);
-
 		/*
 		 * Normally setting the magic number is the last step done
 		 * in a creation function, but a valid log context is needed
@@ -364,7 +366,7 @@
 	}
 
 	if (result == ISC_R_SUCCESS) {
-		destination.file.stream = stderr;
+		destination.file.descriptor = 2;  // 2 is the Stderr file descriptor
 		destination.file.name = NULL;
 		destination.file.versions = ISC_LOG_ROLLNEVER;
 		destination.file.maximum_size = 0;
@@ -383,7 +385,7 @@
 		 */
 		default_channel.channel = ISC_LIST_HEAD(lcfg->channels);
 
-		destination.file.stream = stderr;
+		destination.file.descriptor = 2;  // 2 is the Stderr file descriptor
 		destination.file.name = NULL;
 		destination.file.versions = ISC_LOG_ROLLNEVER;
 		destination.file.maximum_size = 0;
@@ -437,12 +439,10 @@
 	if (result != ISC_R_SUCCESS)
 		return (result);
 
-	LOCK(&lctx->lock);
-
-	old_cfg = lctx->logconfig;
-	lctx->logconfig = lcfg;
-
-	UNLOCK(&lctx->lock);
+	XACT_BEGIN(config)
+		old_cfg = lctx->logconfig;
+		lctx->logconfig = lcfg;
+	XACT_END(config)
 
 	isc_logconfig_destroy(&old_cfg);
 
@@ -467,8 +467,6 @@
 		isc_logconfig_destroy(&lcfg);
 	}
 
-	DESTROYLOCK(&lctx->lock);
-
 	while ((message = ISC_LIST_HEAD(lctx->messages)) != NULL) {
 		ISC_LIST_UNLINK(lctx->messages, message, link);
 
@@ -524,8 +522,8 @@
 			DE_CONST(FILE_NAME(channel), filename);
 			isc_mem_free(mctx, filename);
 
-			if (FILE_STREAM(channel) != NULL)
-				(void)fclose(FILE_STREAM(channel));
+			if (FILE_DESCRIPTOR(channel) != 0)
+				(void)txc_close(FILE_DESCRIPTOR(channel));
 		}
 
 		isc_mem_free(mctx, channel->name);
@@ -740,7 +738,7 @@
 		 */
 		FILE_NAME(channel) =
 			isc_mem_strdup(mctx, destination->file.name);
-		FILE_STREAM(channel) = NULL;
+		FILE_DESCRIPTOR(channel) = 0;
 		FILE_VERSIONS(channel) = destination->file.versions;
 		FILE_MAXSIZE(channel) = destination->file.maximum_size;
 		FILE_MAXREACHED(channel) = ISC_FALSE;
@@ -748,7 +746,7 @@
 
 	case ISC_LOG_TOFILEDESC:
 		FILE_NAME(channel) = NULL;
-		FILE_STREAM(channel) = destination->file.stream;
+		FILE_DESCRIPTOR(channel) = destination->file.descriptor;
 		FILE_MAXSIZE(channel) = 0;
 		FILE_VERSIONS(channel) = ISC_LOG_ROLLNEVER;
 		break;
@@ -947,23 +945,22 @@
 
 	REQUIRE(VALID_CONTEXT(lctx));
 
-	LOCK(&lctx->lock);
-
-	lctx->debug_level = level;
-	/*
-	 * Close ISC_LOG_DEBUGONLY channels if level is zero.
-	 */
-	if (lctx->debug_level == 0)
-		for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
-		     channel != NULL;
-		     channel = ISC_LIST_NEXT(channel, link))
-			if (channel->type == ISC_LOG_TOFILE &&
-			    (channel->flags & ISC_LOG_DEBUGONLY) != 0 &&
-			    FILE_STREAM(channel) != NULL) {
-				(void)fclose(FILE_STREAM(channel));
-				FILE_STREAM(channel) = NULL;
-			}
-	UNLOCK(&lctx->lock);
+	XACT_BEGIN(debug);
+		lctx->debug_level = level;
+		/*
+		 * Close ISC_LOG_DEBUGONLY channels if level is zero.
+		 */
+		if (lctx->debug_level == 0)
+			for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
+			     channel != NULL;
+			     channel = ISC_LIST_NEXT(channel, link))
+				if (channel->type == ISC_LOG_TOFILE &&
+				    (channel->flags & ISC_LOG_DEBUGONLY) != 0 &&
+				    FILE_DESCRIPTOR(channel) != 0) {
+					(void)txc_close(FILE_DESCRIPTOR(channel));
+					FILE_DESCRIPTOR(channel) = 0;
+				}
+	XACT_END(debug);
 }
 
 unsigned int
@@ -1026,17 +1023,17 @@
 
 	REQUIRE(VALID_CONTEXT(lctx));
 
-	LOCK(&lctx->lock);
-	for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
-	     channel != NULL;
-	     channel = ISC_LIST_NEXT(channel, link))
+	XACT_BEGIN(close);
+		for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
+		     channel != NULL;
+		     channel = ISC_LIST_NEXT(channel, link))
 
-		if (channel->type == ISC_LOG_TOFILE &&
-		    FILE_STREAM(channel) != NULL) {
-			(void)fclose(FILE_STREAM(channel));
-			FILE_STREAM(channel) = NULL;
-		}
-	UNLOCK(&lctx->lock);
+			if (channel->type == ISC_LOG_TOFILE &&
+			    FILE_DESCRIPTOR(channel) != 0) {
+				(void)txc_close(FILE_DESCRIPTOR(channel));
+				FILE_DESCRIPTOR(channel) = 0;
+			}
+	XACT_END(close);
 }
 
 /****
@@ -1131,6 +1128,12 @@
 	return (ISC_R_SUCCESS);
 }
 
+
+TM_WAIVER
+long strtol(const char *, char **, int);
+
+
+TM_CALLABLE
 static isc_result_t
 greatest_version(isc_logchannel_t *channel, int *greatestp) {
 	/* XXXDCL HIGHLY NT */
@@ -1202,6 +1205,7 @@
 	return (ISC_R_SUCCESS);
 }
 
+TM_CALLABLE
 static isc_result_t
 roll_log(isc_logchannel_t *channel) {
 	int i, n, greatest;
@@ -1315,7 +1319,7 @@
 	const char *path;
 
 	REQUIRE(channel->type == ISC_LOG_TOFILE);
-	REQUIRE(FILE_STREAM(channel) == NULL);
+	REQUIRE(FILE_DESCRIPTOR(channel) == 0);
 
 	path = FILE_NAME(channel);
 
@@ -1359,7 +1363,16 @@
 		}
 	}
 
-	result = isc_stdio_open(path, "a", &FILE_STREAM(channel));
+	{
+		int fd;
+		fd = txc_open(path, O_CREAT | O_APPEND | O_WRONLY, 0777);
+		if (fd < 0)	{
+			result = isc__errno2result(errno);
+		} else {
+			FILE_DESCRIPTOR(channel) = fd;
+			result = ISC_R_SUCCESS;
+		}
+	}
 
 	return (result);
 }
@@ -1438,317 +1451,319 @@
 	time_string[0]  = '\0';
 	level_string[0] = '\0';
 
-	LOCK(&lctx->lock);
-
-	lctx->buffer[0] = '\0';
+	XACT_BEGIN(bigone);
+		lctx->buffer[0] = '\0';
 	
-	lcfg = lctx->logconfig;
+		lcfg = lctx->logconfig;
 
-	category_channels = ISC_LIST_HEAD(lcfg->channellists[category->id]);
+		category_channels = ISC_LIST_HEAD(lcfg->channellists[category->id]);
 
-	/*
-	 * XXXDCL add duplicate filtering? (To not write multiple times to
-	 * the same source via various channels).
-	 */
-	do {
 		/*
-		 * If the channel list end was reached and a match was made,
-		 * everything is finished.
+		 * XXXDCL add duplicate filtering? (To not write multiple times to
+		 * the same source via various channels).
 		 */
-		if (category_channels == NULL && matched)
-			break;
-
-		if (category_channels == NULL && ! matched &&
-		    category_channels != ISC_LIST_HEAD(lcfg->channellists[0]))
+		do {
 			/*
-			 * No category/module pair was explicitly configured.
-			 * Try the category named "default".
+			 * If the channel list end was reached and a match was made,
+			 * everything is finished.
 			 */
-			category_channels =
-				ISC_LIST_HEAD(lcfg->channellists[0]);
+			if (category_channels == NULL && matched)
+				break;
 
-		if (category_channels == NULL && ! matched)
-			/*
-			 * No matching module was explicitly configured
-			 * for the category named "default".  Use the internal
-			 * default channel.
-			 */
-			category_channels = &default_channel;
+			if (category_channels == NULL && ! matched &&
+			    category_channels != ISC_LIST_HEAD(lcfg->channellists[0]))
+				/*
+				 * No category/module pair was explicitly configured.
+				 * Try the category named "default".
+				 */
+				category_channels =
+					ISC_LIST_HEAD(lcfg->channellists[0]);
 
-		if (category_channels->module != NULL &&
-		    category_channels->module != module) {
-			category_channels = ISC_LIST_NEXT(category_channels,
-							  link);
-			continue;
-		}
+			if (category_channels == NULL && ! matched)
+				/*
+				 * No matching module was explicitly configured
+				 * for the category named "default".  Use the internal
+				 * default channel.
+				 */
+				category_channels = &default_channel;
 
-		matched = ISC_TRUE;
+			if (category_channels->module != NULL &&
+			    category_channels->module != module) {
+				category_channels = ISC_LIST_NEXT(category_channels,
+								  link);
+				continue;
+			}
 
-		channel = category_channels->channel;
-		category_channels = ISC_LIST_NEXT(category_channels, link);
+			matched = ISC_TRUE;
 
-		if (((channel->flags & ISC_LOG_DEBUGONLY) != 0) &&
-		    lctx->debug_level == 0)
-			continue;
+			channel = category_channels->channel;
+			category_channels = ISC_LIST_NEXT(category_channels, link);
 
-		if (channel->level == ISC_LOG_DYNAMIC) {
-			if (lctx->debug_level < level)
+			if (((channel->flags & ISC_LOG_DEBUGONLY) != 0) &&
+			    lctx->debug_level == 0)
 				continue;
-		} else if (channel->level < level)
-			continue;
 
-		if ((channel->flags & ISC_LOG_PRINTTIME) != 0 &&
-		    time_string[0] == '\0') {
-			isc_time_t isctime;
-			
-			TIME_NOW(&isctime);
-			isc_time_formattimestamp(&isctime, time_string,
-						 sizeof(time_string));
-		}
+			if (channel->level == ISC_LOG_DYNAMIC) {
+				if (lctx->debug_level < level)
+					continue;
+			} else if (channel->level < level)
+				continue;
 
-		if ((channel->flags & ISC_LOG_PRINTLEVEL) != 0 &&
-		    level_string[0] == '\0') {
-			if (level < ISC_LOG_CRITICAL)
-				snprintf(level_string, sizeof(level_string),
-					 isc_msgcat_get(isc_msgcat,
-						        ISC_MSGSET_LOG,
-						        ISC_MSG_LEVEL,
-						        "level %d: "),
-					 level);
-			else if (level > ISC_LOG_DYNAMIC)
-				snprintf(level_string, sizeof(level_string),
-					 "%s %d: ", log_level_strings[0],
-					 level);
-			else
-				snprintf(level_string, sizeof(level_string),
-					 "%s: ", log_level_strings[-level]);
-		}
+			if ((channel->flags & ISC_LOG_PRINTTIME) != 0 &&
+			    time_string[0] == '\0') {
+				isc_time_t isctime;
+			
+				TIME_NOW(&isctime);
+				isc_time_formattimestamp(&isctime, time_string,
+							 sizeof(time_string));
+			}
 
-		/*
-		 * Only format the message once.
-		 */
-		if (lctx->buffer[0] == '\0') {
-			(void)vsnprintf(lctx->buffer, sizeof(lctx->buffer),
-					iformat, args);
+			if ((channel->flags & ISC_LOG_PRINTLEVEL) != 0 &&
+			    level_string[0] == '\0') {
+				if (level < ISC_LOG_CRITICAL)
+					txc_snprintf(level_string, sizeof(level_string),
+						 isc_msgcat_get(isc_msgcat,
+							        ISC_MSGSET_LOG,
+							        ISC_MSG_LEVEL,
+							        "level %d: "),
+						 level);
+				else if (level > ISC_LOG_DYNAMIC)
+					txc_snprintf(level_string, sizeof(level_string),
+						 "%s %d: ", log_level_strings[0],
+						 level);
+				else
+					txc_snprintf(level_string, sizeof(level_string),
+						 "%s: ", log_level_strings[-level]);
+			}
 
 			/*
-			 * Check for duplicates.
+			 * Only format the message once.
 			 */
-			if (write_once) {
-				isc_logmessage_t *message, *new;
-				isc_time_t oldest;
-				isc_interval_t interval;
-
-				isc_interval_set(&interval,
-						 lcfg->duplicate_interval, 0);
+			if (lctx->buffer[0] == '\0') {
+				(void)txc_vsnprintf(lctx->buffer, sizeof(lctx->buffer),
+						iformat, args);
 
 				/*
-				 * 'oldest' is the age of the oldest messages
-				 * which fall within the duplicate_interval
-				 * range.
+				 * Check for duplicates.
 				 */
-				TIME_NOW(&oldest);
-				if (isc_time_subtract(&oldest, &interval, &oldest)
-				    != ISC_R_SUCCESS)
+				if (write_once) {
+					isc_logmessage_t *message, *new;
+					isc_time_t oldest;
+					isc_interval_t interval;
+
+					isc_interval_set(&interval,
+							 lcfg->duplicate_interval, 0);
+
 					/*
-					 * Can't effectively do the checking
-					 * without having a valid time.
+					 * 'oldest' is the age of the oldest messages
+					 * which fall within the duplicate_interval
+					 * range.
 					 */
-					message = NULL;
-				else
-					message =ISC_LIST_HEAD(lctx->messages);
-
-				while (message != NULL) {
-					if (isc_time_compare(&message->time,
-							     &oldest) < 0) {
+					TIME_NOW(&oldest);
+					if (isc_time_subtract(&oldest, &interval, &oldest)
+					    != ISC_R_SUCCESS)
 						/*
-						 * This message is older
-						 * than the duplicate_interval,
-						 * so it should be dropped from
-						 * the history.
-						 *
-						 * Setting the interval to be
-						 * to be longer will obviously
-						 * not cause the expired
-						 * message to spring back into
-						 * existence.
+						 * Can't effectively do the checking
+						 * without having a valid time.
 						 */
-						new = ISC_LIST_NEXT(message,
-								    link);
+						message = NULL;
+					else
+						message = ISC_LIST_HEAD(lctx->messages);
+
+					while (message != NULL) {
+						if (isc_time_compare(&message->time,
+								     &oldest) < 0) {
+							/*
+							 * This message is older
+							 * than the duplicate_interval,
+							 * so it should be dropped from
+							 * the history.
+							 *
+							 * Setting the interval to be
+							 * to be longer will obviously
+							 * not cause the expired
+							 * message to spring back into
+							 * existence.
+							 */
+							new = ISC_LIST_NEXT(message,
+									    link);
+
+							ISC_LIST_UNLINK(lctx->messages,
+									message, link);
+
+							isc_mem_put(lctx->mctx,
+								message,
+								sizeof(*message) + 1 +
+								strlen(message->text));
+
+							message = new;
+							continue;
+						}
 
-						ISC_LIST_UNLINK(lctx->messages,
-								message, link);
-
-						isc_mem_put(lctx->mctx,
-							message,
-							sizeof(*message) + 1 +
-							strlen(message->text));
+						/*
+						 * This message is in the duplicate
+						 * filtering interval ...
+						 */
+						if (strcmp(lctx->buffer, message->text)
+						    == 0) {
+							/*
+							 * ... and it is a duplicate.
+							 * Unlock the mutex and
+							 * get the hell out of Dodge.
+							 */
+							// UNLOCK(&lctx->lock);
+							goto bigone_end;
+						}
 
-						message = new;
-						continue;
+						message = ISC_LIST_NEXT(message, link);
 					}
 
 					/*
-					 * This message is in the duplicate
-					 * filtering interval ...
+					 * It wasn't in the duplicate interval,
+					 * so add it to the message list.
 					 */
-					if (strcmp(lctx->buffer, message->text)
-					    == 0) {
+					new = isc_mem_get(lctx->mctx,
+							  sizeof(isc_logmessage_t) +
+							  strlen(lctx->buffer) + 1);
+					if (new != NULL) {
 						/*
-						 * ... and it is a duplicate.
-						 * Unlock the mutex and
-						 * get the hell out of Dodge.
+						 * Put the text immediately after
+						 * the struct.  The strcpy is safe.
 						 */
-						UNLOCK(&lctx->lock);
-						return;
-					}
-
-					message = ISC_LIST_NEXT(message, link);
-				}
+						new->text = (char *)(new + 1);
+						strcpy(new->text, lctx->buffer);
 
-				/*
-				 * It wasn't in the duplicate interval,
-				 * so add it to the message list.
-				 */
-				new = isc_mem_get(lctx->mctx,
-						  sizeof(isc_logmessage_t) +
-						  strlen(lctx->buffer) + 1);
-				if (new != NULL) {
-					/*
-					 * Put the text immediately after
-					 * the struct.  The strcpy is safe.
-					 */
-					new->text = (char *)(new + 1);
-					strcpy(new->text, lctx->buffer);
+						TIME_NOW(&new->time);
 
-					TIME_NOW(&new->time);
-
-					ISC_LIST_APPEND(lctx->messages,
-							new, link);
+						ISC_LIST_APPEND(lctx->messages,
+								new, link);
+					}
 				}
 			}
-		}
 
-		printtime     = ISC_TF((channel->flags & ISC_LOG_PRINTTIME)
-				       != 0);
-		printtag      = ISC_TF((channel->flags & ISC_LOG_PRINTTAG)
-				       != 0 && lcfg->tag != NULL);
-		printcategory = ISC_TF((channel->flags & ISC_LOG_PRINTCATEGORY)
-				       != 0);
-		printmodule   = ISC_TF((channel->flags & ISC_LOG_PRINTMODULE)
-				       != 0);
-		printlevel    = ISC_TF((channel->flags & ISC_LOG_PRINTLEVEL)
-				       != 0);
-
-		switch (channel->type) {
-		case ISC_LOG_TOFILE:
-			if (FILE_MAXREACHED(channel)) {
-				/*
-				 * If the file can be rolled, OR
-				 * If the file no longer exists, OR
-				 * If the file is less than the maximum size,
-				 *    (such as if it had been renamed and
-				 *     a new one touched, or it was truncated
-				 *     in place)
-				 * ... then close it to trigger reopening.
-				 */
-				if (FILE_VERSIONS(channel) !=
-				    ISC_LOG_ROLLNEVER ||
-				    (stat(FILE_NAME(channel), &statbuf) != 0 &&
-				     errno == ENOENT) ||
-				    statbuf.st_size < FILE_MAXSIZE(channel)) {
-					(void)fclose(FILE_STREAM(channel));
-					FILE_STREAM(channel) = NULL;
-					FILE_MAXREACHED(channel) = ISC_FALSE;
-				} else
+			printtime     = ISC_TF((channel->flags & ISC_LOG_PRINTTIME)
+					       != 0);
+			printtag      = ISC_TF((channel->flags & ISC_LOG_PRINTTAG)
+					       != 0 && lcfg->tag != NULL);
+			printcategory = ISC_TF((channel->flags & ISC_LOG_PRINTCATEGORY)
+					       != 0);
+			printmodule   = ISC_TF((channel->flags & ISC_LOG_PRINTMODULE)
+					       != 0);
+			printlevel    = ISC_TF((channel->flags & ISC_LOG_PRINTLEVEL)
+					       != 0);
+
+			switch (channel->type) {
+			case ISC_LOG_TOFILE:
+				if (FILE_MAXREACHED(channel)) {
 					/*
-					 * Eh, skip it.
+					 * If the file can be rolled, OR
+					 * If the file no longer exists, OR
+					 * If the file is less than the maximum size,
+					 *    (such as if it had been renamed and
+					 *     a new one touched, or it was truncated
+					 *     in place)
+					 * ... then close it to trigger reopening.
 					 */
-					break;
-			}
-
-			if (FILE_STREAM(channel) == NULL) {
-				result = isc_log_open(channel);
-				if (result != ISC_R_SUCCESS &&
-				    result != ISC_R_MAXSIZE &&
-				    (channel->flags & ISC_LOG_OPENERR) == 0) {
-					syslog(LOG_ERR,
-					       "isc_log_open '%s' failed: %s",
-					       FILE_NAME(channel),
-					       isc_result_totext(result));
-					channel->flags |= ISC_LOG_OPENERR;
+					if (FILE_VERSIONS(channel) !=
+					    ISC_LOG_ROLLNEVER ||
+					    (txc_stat(FILE_NAME(channel), &statbuf) != 0 &&
+					     errno == ENOENT) ||
+					    statbuf.st_size < FILE_MAXSIZE(channel)) {
+						(void)txc_close(FILE_DESCRIPTOR(channel));
+						FILE_DESCRIPTOR(channel) = 0;
+						FILE_MAXREACHED(channel) = ISC_FALSE;
+					} else
+						/*
+						 * Eh, skip it.
+						 */
+						break;
 				}
-				if (result != ISC_R_SUCCESS)
-					break;
-				channel->flags &= ~ISC_LOG_OPENERR;
-			}
-			/* FALLTHROUGH */
-
-		case ISC_LOG_TOFILEDESC:
-			fprintf(FILE_STREAM(channel), "%s%s%s%s%s%s%s%s%s%s\n",
-				printtime     ? time_string	: "",
-				printtime     ? " "		: "",
-				printtag      ? lcfg->tag	: "",
-				printtag      ? ": "		: "",
-				printcategory ? category->name	: "",
-				printcategory ? ": "		: "",
-				printmodule   ? (module != NULL ? module->name
-						 		: "no_module")
-					      			: "",
-				printmodule   ? ": "		: "",
-				printlevel    ? level_string	: "",
-				lctx->buffer);
 
-			fflush(FILE_STREAM(channel));
+				if (FILE_DESCRIPTOR(channel) == 0) {
+					result = isc_log_open(channel);
+					if (result != ISC_R_SUCCESS &&
+					    result != ISC_R_MAXSIZE &&
+					    (channel->flags & ISC_LOG_OPENERR) == 0) {
+						syslog(LOG_ERR,
+						       "isc_log_open '%s' failed: %s",
+						       FILE_NAME(channel),
+						       isc_result_totext(result));
+						channel->flags |= ISC_LOG_OPENERR;
+					}
+					if (result != ISC_R_SUCCESS)
+						break;
+					channel->flags &= ~ISC_LOG_OPENERR;
+				}
+				/* FALLTHROUGH */
 
-			/*
-			 * If the file now exceeds its maximum size
-			 * threshold, note it so that it will not be logged
-			 * to any more.
-			 */
-			if (FILE_MAXSIZE(channel) > 0) {
-				INSIST(channel->type == ISC_LOG_TOFILE);
+			case ISC_LOG_TOFILEDESC:
+				{
+					char message[1024];
+					int size = txc_sprintf(message,
+						"%s%s%s%s%s%s%s%s%s%s\n",
+						printtime     ? time_string	: "",
+						printtime     ? " "		: "",
+						printtag      ? lcfg->tag	: "",
+						printtag      ? ": "		: "",
+						printcategory ? category->name	: "",
+						printcategory ? ": "		: "",
+						printmodule   ? (module != NULL ? module->name
+								 		: "no_module")
+							      			: "",
+						printmodule   ? ": "		: "",
+						printlevel    ? level_string	: "",
+						lctx->buffer);
+					txc_write(FILE_DESCRIPTOR(channel), message, size, APPEND_ONLY);
+					txc_fsync(FILE_DESCRIPTOR(channel));
 
-				/* XXXDCL NT fstat/fileno */
-				/* XXXDCL complain if fstat fails? */
-				if (fstat(fileno(FILE_STREAM(channel)),
-					  &statbuf) >= 0 &&
-				    statbuf.st_size > FILE_MAXSIZE(channel))
-					FILE_MAXREACHED(channel) = ISC_TRUE;
-			}
+					/*
+					 * If the file now exceeds its maximum size
+					 * threshold, note it so that it will not be logged
+					 * to any more.
+					 */
+					if (FILE_MAXSIZE(channel) > 0) {
+						INSIST(channel->type == ISC_LOG_TOFILE);
 
-			break;
+						/* XXXDCL NT fstat/fileno */
+						/* XXXDCL complain if fstat fails? */
+						if (txc_stat(FILE_NAME(channel),
+							  &statbuf) >= 0 &&
+						    statbuf.st_size > FILE_MAXSIZE(channel))
+							FILE_MAXREACHED(channel) = ISC_TRUE;
+					}
 
-		case ISC_LOG_TOSYSLOG:
-			if (level > 0)
-				syslog_level = LOG_DEBUG;
-			else if (level < ISC_LOG_CRITICAL)
-				syslog_level = LOG_CRIT;
-			else
-				syslog_level = syslog_map[-level];
+					break;
+				}
 
-			(void)syslog(FACILITY(channel) | syslog_level,
-			       "%s%s%s%s%s%s%s%s%s%s",
-			       printtime     ? time_string	: "",
-			       printtime     ? " "		: "",
-			       printtag      ? lcfg->tag	: "",
-			       printtag      ? ": "		: "",
-			       printcategory ? category->name	: "",
-			       printcategory ? ": "		: "",
-			       printmodule   ? (module != NULL	? module->name
-						 		: "no_module")
-					      			: "",
-			       printmodule   ? ": "		: "",
-			       printlevel    ? level_string	: "",
-			       lctx->buffer);
-			break;
+			case ISC_LOG_TOSYSLOG:
+				if (level > 0)
+					syslog_level = LOG_DEBUG;
+				else if (level < ISC_LOG_CRITICAL)
+					syslog_level = LOG_CRIT;
+				else
+					syslog_level = syslog_map[-level];
 
-		case ISC_LOG_TONULL:
-			break;
+				(void)syslog(FACILITY(channel) | syslog_level,
+				       "%s%s%s%s%s%s%s%s%s%s",
+				       printtime     ? time_string	: "",
+				       printtime     ? " "		: "",
+				       printtag      ? lcfg->tag	: "",
+				       printtag      ? ": "		: "",
+				       printcategory ? category->name	: "",
+				       printcategory ? ": "		: "",
+				       printmodule   ? (module != NULL	? module->name
+							 		: "no_module")
+						      			: "",
+				       printmodule   ? ": "		: "",
+				       printlevel    ? level_string	: "",
+				       lctx->buffer);
+				break;
 
-		}
+			case ISC_LOG_TONULL:
+				break;
 
-	} while (1);
+			}
 
-	UNLOCK(&lctx->lock);
+		} while (1);
+	XACT_END(bigone);
 }
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/result.c changed/lib/isc/result.c
--- bind-9.3.5-P2/lib/isc/result.c	2007-08-28 02:19:15.000000000 -0500
+++ changed/lib/isc/result.c	2008-10-28 00:16:22.000000000 -0500
@@ -28,6 +28,7 @@
 #include <isc/once.h>
 #include <isc/resultclass.h>
 #include <isc/util.h>
+#include <txc.h>
 
 typedef struct resulttable {
 	unsigned int				base;
@@ -106,7 +107,6 @@
 
 static isc_once_t 				once = ISC_ONCE_INIT;
 static ISC_LIST(resulttable)			tables;
-static isc_mutex_t				lock;
 
 static isc_result_t
 register_table(unsigned int base, unsigned int nresults, const char **text,
@@ -132,11 +132,11 @@
 	table->set = set;
 	ISC_LINK_INIT(table, link);
 
-	LOCK(&lock);
+	XACT_BEGIN(lock);
 
-	ISC_LIST_APPEND(tables, table, link);
+		ISC_LIST_APPEND(tables, table, link);
 
-	UNLOCK(&lock);
+	XACT_END(lock);
 
 	return (ISC_R_SUCCESS);
 }
@@ -145,7 +145,6 @@
 initialize_action(void) {
 	isc_result_t result;
 
-	RUNTIME_CHECK(isc_mutex_init(&lock) == ISC_R_SUCCESS);
 	ISC_LIST_INIT(tables);
 
 	result = register_table(ISC_RESULTCLASS_ISC, ISC_R_NRESULTS, text,
@@ -164,6 +163,7 @@
 	RUNTIME_CHECK(isc_once_do(&once, initialize_action) == ISC_R_SUCCESS);
 }
 
+TM_CALLABLE
 const char *
 isc_result_totext(isc_result_t result) {
 	resulttable *table;
@@ -172,30 +172,30 @@
 
 	initialize();
 
-	LOCK(&lock);
+	XACT_BEGIN(lock);
 
-	text = NULL;
-	for (table = ISC_LIST_HEAD(tables);
-	     table != NULL;
-	     table = ISC_LIST_NEXT(table, link)) {
-		if (result >= table->base && result <= table->last) {
-			index = (int)(result - table->base);
-			default_text = table->text[index];
-			/*
-			 * Note: we use 'index + 1' as the message number
-			 * instead of index because isc_msgcat_get() requires
-			 * the message number to be > 0.
-			 */
-			text = isc_msgcat_get(table->msgcat, table->set,
-					      index + 1, default_text);
-			break;
+		text = NULL;
+		for (table = ISC_LIST_HEAD(tables);
+		     table != NULL;
+		     table = ISC_LIST_NEXT(table, link)) {
+			if (result >= table->base && result <= table->last) {
+				index = (int)(result - table->base);
+				default_text = table->text[index];
+				/*
+				 * Note: we use 'index + 1' as the message number
+				 * instead of index because isc_msgcat_get() requires
+				 * the message number to be > 0.
+				 */
+				text = isc_msgcat_get(table->msgcat, table->set,
+						      index + 1, default_text);
+				break;
+			}
 		}
-	}
-	if (text == NULL)
-		text = isc_msgcat_get(isc_msgcat, ISC_RESULT_UNAVAILABLESET,
-				      1, "(result code text not available)");
+		if (text == NULL)
+			text = isc_msgcat_get(isc_msgcat, ISC_RESULT_UNAVAILABLESET,
+					      1, "(result code text not available)");
 
-	UNLOCK(&lock);
+	XACT_END(lock);
 
 	return (text);
 }
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/unix/Makefile.in changed/lib/isc/unix/Makefile.in
--- bind-9.3.5-P2/lib/isc/unix/Makefile.in	2008-10-28 00:33:21.000000000 -0500
+++ changed/lib/isc/unix/Makefile.in	2008-10-28 00:30:19.000000000 -0500
@@ -21,7 +21,6 @@
 
 CINCLUDES =	-I${srcdir}/include \
 		-I${srcdir}/../@ISC_THREAD_DIR@/include \
-		-I$(PWD)/../../../../xCalls/src/include \
 		-I../include \
 		-I${srcdir}/../include \
 		-I${srcdir}/..
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/unix/errno2result.c changed/lib/isc/unix/errno2result.c
--- bind-9.3.5-P2/lib/isc/unix/errno2result.c	2007-08-28 02:19:17.000000000 -0500
+++ changed/lib/isc/unix/errno2result.c	2008-10-27 23:47:22.000000000 -0500
@@ -31,6 +31,7 @@
  * of this function should add any expected errors that are
  * not already there.
  */
+TM_WAIVER
 isc_result_t
 isc__errno2result(int posixerrno) {
 	char strbuf[ISC_STRERRORSIZE];
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/unix/errno2result.h changed/lib/isc/unix/errno2result.h
--- bind-9.3.5-P2/lib/isc/unix/errno2result.h	2004-03-06 02:14:59.000000000 -0600
+++ changed/lib/isc/unix/errno2result.h	2008-10-27 23:39:03.000000000 -0500
@@ -29,6 +29,7 @@
 
 ISC_LANG_BEGINDECLS
 
+TM_WAIVER
 isc_result_t
 isc__errno2result(int posixerrno);
 
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/unix/include/isc/dir.h changed/lib/isc/unix/include/isc/dir.h
--- bind-9.3.5-P2/lib/isc/unix/include/isc/dir.h	2007-08-28 02:19:17.000000000 -0500
+++ changed/lib/isc/unix/include/isc/dir.h	2008-10-27 23:52:07.000000000 -0500
@@ -58,6 +58,7 @@
 void
 isc_dir_init(isc_dir_t *dir);
 
+__attribute__((tm_unknown))
 isc_result_t
 isc_dir_open(isc_dir_t *dir, const char *dirname);
 
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/unix/include/isc/strerror.h changed/lib/isc/unix/include/isc/strerror.h
--- bind-9.3.5-P2/lib/isc/unix/include/isc/strerror.h	2007-08-28 02:19:17.000000000 -0500
+++ changed/lib/isc/unix/include/isc/strerror.h	2008-10-27 20:38:09.000000000 -0500
@@ -34,6 +34,7 @@
  * Requires:
  * 	'buf' to be non NULL.
  */
+TM_CALLABLE
 void
 isc__strerror(int num, char *buf, size_t bufsize);
 
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/unix/include/isc/time.h changed/lib/isc/unix/include/isc/time.h
--- bind-9.3.5-P2/lib/isc/unix/include/isc/time.h	2007-08-28 02:19:17.000000000 -0500
+++ changed/lib/isc/unix/include/isc/time.h	2008-10-27 23:29:41.000000000 -0500
@@ -42,6 +42,7 @@
 
 ISC_LANG_BEGINDECLS
 
+TM_WAIVER
 void
 isc_interval_set(isc_interval_t *i,
 		 unsigned int seconds, unsigned int nanoseconds);
@@ -124,6 +125,7 @@
  *	't' is a valid pointer.
  */
 
+TM_CALLABLE
 isc_result_t
 isc_time_now(isc_time_t *t);
 /*
@@ -168,6 +170,7 @@
  *		be represented in the current definition of isc_time_t.
  */
 
+TM_WAIVER
 int
 isc_time_compare(const isc_time_t *t1, const isc_time_t *t2);
 /*
@@ -200,6 +203,7 @@
  *		be represented in the current definition of isc_time_t.
  */
 
+TM_CALLABLE
 isc_result_t
 isc_time_subtract(const isc_time_t *t, const isc_interval_t *i,
 		  isc_time_t *result);
@@ -280,6 +284,7 @@
  *	The returned value is less than 1*10^9.
  */
 
+TM_WAIVER
 void
 isc_time_formattimestamp(const isc_time_t *t, char *buf, unsigned int len);
 /*
diff -Naur -x '._*' -x 'Makefile' -x '*.i' -x '*~' -x 'make' -x '*.log' -x 'doc' -x 'contrib' -x 'tests' -x 'config.h' -x 'config.status' -x 'isc-config.h' -x '*.kdev*' -x 'platform.h' -x 'netdb.h' -x 'Doxyfile' -x 'port_*.h' old/lib/isc/unix/strerror.c bind-9.3.5-P2/lib/isc/unix/strerror.c
--- old/lib/isc/unix/strerror.c	2007-08-28 02:19:17.000000000 -0500
+++ bind-9.3.5-P2/lib/isc/unix/strerror.c	2008-10-28 17:19:30.000000000 -0500
@@ -27,38 +27,32 @@
 #include <isc/print.h>
 #include <isc/strerror.h>
 #include <isc/util.h>
+#include <txc.h>

 #ifdef HAVE_STRERROR
-/*
- * We need to do this this way for profiled locks.
- */
-static isc_mutex_t isc_strerror_lock;
-static void init_lock(void) {
-	RUNTIME_CHECK(isc_mutex_init(&isc_strerror_lock) == ISC_R_SUCCESS);
-}
+
 #else
 extern const char * const sys_errlist[];
 extern const int sys_nerr;
 #endif
+static isc_once_t once = ISC_ONCE_INIT;

+TM_CALLABLE
 void
 isc__strerror(int num, char *buf, size_t size) {
 #ifdef HAVE_STRERROR
 	char *msg;
 	unsigned int unum = num;
-	static isc_once_t once = ISC_ONCE_INIT;

 	REQUIRE(buf != NULL);

-	RUNTIME_CHECK(isc_once_do(&once, init_lock) == ISC_R_SUCCESS);
-
-	LOCK(&isc_strerror_lock);
-	msg = strerror(num);
-	if (msg != NULL)
-		snprintf(buf, size, "%s", msg);
-	else
-		snprintf(buf, size, "Unknown error: %u", unum);
-	UNLOCK(&isc_strerror_lock);
+	XACT_BEGIN(isc_strerror_lock);
+		msg = txc_strerror(num);
+		if (msg != NULL)
+			txc_snprintf(buf, size, "%s", msg);
+		else
+			txc_snprintf(buf, size, "Unknown error: %u", unum);
+	XACT_END(isc_strerror_lock);
 #else
 	unsigned int unum = num;

diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/unix/time.c changed/lib/isc/unix/time.c
--- bind-9.3.5-P2/lib/isc/unix/time.c	2004-03-06 02:15:03.000000000 -0600
+++ changed/lib/isc/unix/time.c	2008-10-27 23:29:51.000000000 -0500
@@ -56,6 +56,7 @@
 isc_interval_t *isc_interval_zero = &zero_interval;
 
 #if ISC_FIX_TV_USEC
+TM_WAIVER
 static inline void
 fix_tv_usec(struct timeval *tv) {
 	isc_boolean_t fixed = ISC_FALSE;
@@ -76,11 +77,13 @@
 	/*
 	 * Call syslog directly as was are called from the logging functions.
 	 */
-	if (fixed)
-		(void)syslog(LOG_ERR, "gettimeofday returned bad tv_usec: corrected");
+	// EDIT: This basically never happens...
+	//if (fixed)
+		// (void)syslog(LOG_ERR, "gettimeofday returned bad tv_usec: corrected");
 }
 #endif
 
+TM_WAIVER
 void
 isc_interval_set(isc_interval_t *i,
 		 unsigned int seconds, unsigned int nanoseconds)
@@ -140,6 +143,11 @@
 }
 
 
+TM_WAIVER
+int
+gettimeofday(struct timeval* tp, void* tzp);
+
+TM_CALLABLE
 isc_result_t
 isc_time_now(isc_time_t *t) {
 	struct timeval tv;
@@ -233,6 +241,7 @@
 	return (ISC_R_SUCCESS);
 }
 
+TM_WAIVER
 int
 isc_time_compare(const isc_time_t *t1, const isc_time_t *t2) {
 	REQUIRE(t1 != NULL && t2 != NULL);
@@ -275,6 +284,7 @@
 	return (ISC_R_SUCCESS);
 }
 
+TM_CALLABLE
 isc_result_t
 isc_time_subtract(const isc_time_t *t, const isc_interval_t *i,
 		  isc_time_t *result)
@@ -394,6 +404,10 @@
 	return ((isc_uint32_t)t->nanoseconds);
 }
 
+TM_WAIVER
+size_t strftime(char*, size_t, const char*, const struct tm*);
+
+TM_WAIVER
 void
 isc_time_formattimestamp(const isc_time_t *t, char *buf, unsigned int len) {
 	time_t now;
diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/win32/include/isc/time.h changed/lib/isc/win32/include/isc/time.h
--- bind-9.3.5-P2/lib/isc/win32/include/isc/time.h	2007-08-28 02:19:17.000000000 -0500
+++ changed/lib/isc/win32/include/isc/time.h	2008-10-27 12:15:31.000000000 -0500
@@ -43,6 +43,7 @@
 
 ISC_LANG_BEGINDECLS
 
+TM_WAIVER
 void
 isc_interval_set(isc_interval_t *i,
 		 unsigned int seconds, unsigned int nanoseconds);
@@ -151,6 +152,7 @@
  *		be represented in the current definition of isc_time_t.
  */
 
+TM_WAIVER
 int
 isc_time_compare(const isc_time_t *t1, const isc_time_t *t2);
 /*
@@ -183,6 +185,7 @@
  *		be represented in the current definition of isc_time_t.
  */
 
+TM_WAIVER
 isc_result_t
 isc_time_subtract(const isc_time_t *t, const isc_interval_t *i,
 		  isc_time_t *result);

diff -Naur -x '._*' -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/mem.c changed/lib/isc/mem.c
--- old/lib/isc/mem.c	2007-11-26 17:45:51.000000000 -0600
+++ bind-9.3.5-P2/lib/isc/mem.c	2008-10-29 00:22:34.000000000 -0500
@@ -33,6 +33,7 @@
 
 #include <isc/mutex.h>
 #include <isc/util.h>
+#include <txc.h>
 
 #ifndef ISC_MEM_DEBUGGING
 #define ISC_MEM_DEBUGGING 0
@@ -115,7 +116,7 @@
 struct isc_mem {
 	unsigned int		magic;
 	isc_ondestroy_t		ondestroy;
-	isc_mutex_t		lock;
+	// isc_mutex_t		lock;
 	isc_memalloc_t		memalloc;
 	isc_memfree_t		memfree;
 	void *			arg;
@@ -158,7 +159,7 @@
 struct isc_mempool {
 	/* always unlocked */
 	unsigned int	magic;		/* magic number */
-	isc_mutex_t    *lock;		/* optional lock */
+	// isc_mutex_t    *lock;		/* optional lock */
 	isc_mem_t      *mctx;		/* our memory context */
 	/* locked via the memory context's lock */
 	ISC_LINK(isc_mempool_t)	link;	/* next pool in this mem context */
@@ -195,12 +196,14 @@
 	} while (0)
 #define DELETE_TRACE(a, b, c, d, e)	delete_trace_entry(a, b, c, d, e)
 
+TM_CALLABLE
 static void
 print_active(isc_mem_t *ctx, FILE *out);
 
 /*
  * mctx must be locked.
  */
+TM_CALLABLE
 static inline void
 add_trace_entry(isc_mem_t *mctx, const void *ptr, unsigned int size
 		FLARG)
@@ -209,7 +212,7 @@
 	unsigned int i;
 
 	if ((isc_mem_debugging & ISC_MEM_DEBUGTRACE) != 0)
-		fprintf(stderr, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+		txc_fprintf(stderr, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
 					       ISC_MSG_ADDTRACE,
 					       "add %p size %u "
 					       "file %s line %u mctx %p\n"),
@@ -239,7 +242,7 @@
 		dl = ISC_LIST_NEXT(dl, link);
 	}
 
-	dl = malloc(sizeof(debuglink_t));
+	dl = txc_malloc(sizeof(debuglink_t));
 	INSIST(dl != NULL);
 
 	ISC_LINK_INIT(dl, link);
@@ -259,6 +262,7 @@
 	ISC_LIST_PREPEND(mctx->debuglist[size], dl, link);
 }
 
+TM_CALLABLE
 static inline void
 delete_trace_entry(isc_mem_t *mctx, const void *ptr, unsigned int size,
 		   const char *file, unsigned int line)
@@ -267,7 +271,7 @@
 	unsigned int i;
 
 	if ((isc_mem_debugging & ISC_MEM_DEBUGTRACE) != 0)
-		fprintf(stderr, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+		txc_fprintf(stderr, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
 					       ISC_MSG_DELTRACE,
 					       "del %p size %u "
 					       "file %s line %u mctx %p\n"),
@@ -293,7 +297,7 @@
 				if (dl->count == 0) {
 					ISC_LIST_UNLINK(mctx->debuglist[size],
 							dl, link);
-					free(dl);
+					txc_free(dl);
 				}
 				return;
 			}
@@ -594,6 +598,7 @@
 /*
  * Perform a malloc, doing memory filling and overrun detection as necessary.
  */
+TM_CALLABLE
 static inline void *
 mem_get(isc_mem_t *ctx, size_t size) {
 	char *ret;
@@ -622,6 +627,7 @@
 /*
  * Perform a free, doing memory filling and overrun detection as necessary.
  */
+TM_CALLABLE
 static inline void
 mem_put(isc_mem_t *ctx, void *mem, size_t size) {
 #if ISC_MEM_CHECKOVERRUN
@@ -638,6 +644,7 @@
 /*
  * Update internal counters after a memory get.
  */
+TM_CALLABLE
 static inline void
 mem_getstats(isc_mem_t *ctx, size_t size) {
 	ctx->total += size;
@@ -655,6 +662,7 @@
 /*
  * Update internal counters after a memory put.
  */
+TM_CALLABLE
 static inline void
 mem_putstats(isc_mem_t *ctx, void *ptr, size_t size) {
 	UNUSED(ptr);
@@ -676,19 +684,20 @@
 /*
  * Private.
  */
-
+TM_CALLABLE
 static void *
 default_memalloc(void *arg, size_t size) {
 	UNUSED(arg);
 	if (size == 0U)
 		size = 1;
-	return (malloc(size));
+	return (txc_malloc(size));
 }
 
+TM_CALLABLE
 static void
 default_memfree(void *arg, void *ptr) {
 	UNUSED(arg);
-	free(ptr);
+	txc_free(ptr);
 }
 
 /*
@@ -717,15 +726,6 @@
 	if (ctx == NULL)
 		return (ISC_R_NOMEMORY);
 
-	if (isc_mutex_init(&ctx->lock) != ISC_R_SUCCESS) {
-		UNEXPECTED_ERROR(__FILE__, __LINE__,
-				 "isc_mutex_init() %s",
-				 isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,
-						ISC_MSG_FAILED, "failed"));
-		(memfree)(arg, ctx);
-		return (ISC_R_UNEXPECTED);
-	}
-
 	if (init_max_size == 0U)
 		ctx->max_size = DEF_MAX_SIZE;
 	else
@@ -816,7 +816,7 @@
 		if (ctx->debuglist != NULL)
 			(ctx->memfree)(ctx->arg, ctx->debuglist);
 #endif /* ISC_MEM_TRACKLINES */
-		DESTROYLOCK(&ctx->lock);
+//		DESTROYLOCK(&ctx->lock);
 		(memfree)(arg, ctx);
 	}
 
@@ -890,7 +890,6 @@
 
 	ondest = ctx->ondestroy;
 
-	DESTROYLOCK(&ctx->lock);
 	(ctx->memfree)(ctx->arg, ctx);
 
 	isc_ondestroy_notify(&ondest, ctx);
@@ -901,9 +900,9 @@
 	REQUIRE(VALID_CONTEXT(source));
 	REQUIRE(targetp != NULL && *targetp == NULL);
 
-	LOCK(&source->lock);
-	source->references++;
-	UNLOCK(&source->lock);
+	XACT_BEGIN(source)
+		source->references++;
+	XACT_END(source)
 
 	*targetp = source;
 }
@@ -917,12 +916,12 @@
 	ctx = *ctxp;
 	REQUIRE(VALID_CONTEXT(ctx));
 
-	LOCK(&ctx->lock);
-	INSIST(ctx->references > 0);
-	ctx->references--;
-	if (ctx->references == 0)
-		want_destroy = ISC_TRUE;
-	UNLOCK(&ctx->lock);
+	XACT_BEGIN(ctxp)
+		INSIST(ctx->references > 0);
+		ctx->references--;
+		if (ctx->references == 0)
+			want_destroy = ISC_TRUE;
+	XACT_END(ctxp)
 
 	if (want_destroy)
 		destroy(ctx);
@@ -957,21 +956,21 @@
 	*ctxp = NULL;
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, ptr, size);
+	XACT_BEGIN(ctxp)
+		mem_putunlocked(ctx, ptr, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
 	mem_put(ctx, ptr, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, ptr, size);
+	XACT_BEGIN(ctxp)
+		mem_putstats(ctx, ptr, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
-	INSIST(ctx->references > 0);
-	ctx->references--;
-	if (ctx->references == 0)
-		want_destroy = ISC_TRUE;
+		DELETE_TRACE(ctx, ptr, size, file, line);
+		INSIST(ctx->references > 0);
+		ctx->references--;
+		if (ctx->references == 0)
+			want_destroy = ISC_TRUE;
 
-	UNLOCK(&ctx->lock);
+	XACT_END(ctxp)
 
 	if (want_destroy)
 		destroy(ctx);
@@ -990,14 +989,14 @@
 	ctx = *ctxp;
 	REQUIRE(VALID_CONTEXT(ctx));
 
-	LOCK(&ctx->lock);
+	XACT_BEGIN(ctxp)
 #if ISC_MEM_TRACKLINES
-	if (ctx->references != 1)
-		print_active(ctx, stderr);
+		if (ctx->references != 1)
+			print_active(ctx, stderr);
 #endif
-	REQUIRE(ctx->references == 1);
-	ctx->references--;
-	UNLOCK(&ctx->lock);
+		REQUIRE(ctx->references == 1);
+		ctx->references--;
+	XACT_END(ctxp)
 
 	destroy(ctx);
 
@@ -1008,14 +1007,15 @@
 isc_mem_ondestroy(isc_mem_t *ctx, isc_task_t *task, isc_event_t **event) {
 	isc_result_t res;
 
-	LOCK(&ctx->lock);
-	res = isc_ondestroy_register(&ctx->ondestroy, task, event);
-	UNLOCK(&ctx->lock);
+	XACT_BEGIN(ctx)
+		res = isc_ondestroy_register(&ctx->ondestroy, task, event);
+	XACT_END(ctx)
 
 	return (res);
 }
 
 
+TM_CALLABLE
 void *
 isc__mem_get(isc_mem_t *ctx, size_t size FLARG) {
 	void *ptr;
@@ -1024,29 +1024,29 @@
 	REQUIRE(VALID_CONTEXT(ctx));
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	ptr = mem_getunlocked(ctx, size);
+	XACT_BEGIN(ctx)
+		ptr = mem_getunlocked(ctx, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
 	ptr = mem_get(ctx, size);
-	LOCK(&ctx->lock);
-	if (ptr != NULL)
-		mem_getstats(ctx, size);
+	XACT_BEGIN(ctx)
+		if (ptr != NULL)
+			mem_getstats(ctx, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	ADD_TRACE(ctx, ptr, size, file, line);
-	if (ctx->hi_water != 0U && !ctx->hi_called &&
-	    ctx->inuse > ctx->hi_water) {
-		ctx->hi_called = ISC_TRUE;
-		call_water = ISC_TRUE;
-	}
-	if (ctx->inuse > ctx->maxinuse) {
-		ctx->maxinuse = ctx->inuse;
-		if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
-		    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
-			fprintf(stderr, "maxinuse = %lu\n",
-				(unsigned long)ctx->inuse);
-	}
-	UNLOCK(&ctx->lock);
+		ADD_TRACE(ctx, ptr, size, file, line);
+		if (ctx->hi_water != 0U && !ctx->hi_called &&
+		    ctx->inuse > ctx->hi_water) {
+			ctx->hi_called = ISC_TRUE;
+			call_water = ISC_TRUE;
+		}
+		if (ctx->inuse > ctx->maxinuse) {
+			ctx->maxinuse = ctx->inuse;
+			if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
+			    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
+				txc_fprintf(stderr, "maxinuse = %lu\n",
+					(unsigned long)ctx->inuse);
+		}
+	XACT_END(ctx)
 
 	if (call_water)
 		(ctx->water)(ctx->water_arg, ISC_MEM_HIWATER);
@@ -1054,6 +1054,7 @@
 	return (ptr);
 }
 
+TM_CALLABLE
 void
 isc__mem_put(isc_mem_t *ctx, void *ptr, size_t size FLARG)
 {
@@ -1063,35 +1064,36 @@
 	REQUIRE(ptr != NULL);
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, ptr, size);
+	XACT_BEGIN(ctx)
+		mem_putunlocked(ctx, ptr, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
 	mem_put(ctx, ptr, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, ptr, size);
+	XACT_BEGIN(ctx)
+		mem_putstats(ctx, ptr, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
+		DELETE_TRACE(ctx, ptr, size, file, line);
 
-	/*
-	 * The check against ctx->lo_water == 0 is for the condition
-	 * when the context was pushed over hi_water but then had
-	 * isc_mem_setwater() called with 0 for hi_water and lo_water.
-	 */
-	if (ctx->hi_called && 
-	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
-		ctx->hi_called = ISC_FALSE;
+		/*
+		 * The check against ctx->lo_water == 0 is for the condition
+		 * when the context was pushed over hi_water but then had
+		 * isc_mem_setwater() called with 0 for hi_water and lo_water.
+		 */
+		if (ctx->hi_called && 
+		    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
+			ctx->hi_called = ISC_FALSE;
 
-		if (ctx->water != NULL)
-			call_water = ISC_TRUE;
-	}
-	UNLOCK(&ctx->lock);
+			if (ctx->water != NULL)
+				call_water = ISC_TRUE;
+		}
+	XACT_END(ctx)
 
 	if (call_water)
 		(ctx->water)(ctx->water_arg, ISC_MEM_LOWATER);
 }
 
 #if ISC_MEM_TRACKLINES
+TM_CALLABLE
 static void
 print_active(isc_mem_t *mctx, FILE *out) {
 	if (mctx->debuglist != NULL) {
@@ -1100,7 +1102,7 @@
 		const char *format;
 		isc_boolean_t found;
 
-		fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+		txc_fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
 					    ISC_MSG_DUMPALLOC,
 					    "Dump of all outstanding "
 					    "memory allocations:\n"));
@@ -1117,7 +1119,7 @@
 			while (dl != NULL) {
 				for (j = 0; j < DEBUGLIST_COUNT; j++)
 					if (dl->ptr[j] != NULL)
-						fprintf(out, format,
+						txc_fprintf(out, format,
 							dl->ptr[j],
 							dl->size[j],
 							dl->file[j],
@@ -1126,7 +1128,7 @@
 			}
 		}
 		if (!found)
-			fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+			txc_fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
 						    ISC_MSG_NONE, "\tNone.\n"));
 	}
 }
@@ -1142,69 +1144,69 @@
 	const isc_mempool_t *pool;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
+	XACT_BEGIN(ctx)
 
-	for (i = 0; i <= ctx->max_size; i++) {
-		s = &ctx->stats[i];
+		for (i = 0; i <= ctx->max_size; i++) {
+			s = &ctx->stats[i];
 
-		if (s->totalgets == 0U && s->gets == 0U)
-			continue;
-		fprintf(out, "%s%5lu: %11lu gets, %11lu rem",
-			(i == ctx->max_size) ? ">=" : "  ",
-			(unsigned long) i, s->totalgets, s->gets);
+			if (s->totalgets == 0U && s->gets == 0U)
+				continue;
+			txc_fprintf(out, "%s%5lu: %11lu gets, %11lu rem",
+				(i == ctx->max_size) ? ">=" : "  ",
+				(unsigned long) i, s->totalgets, s->gets);
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		if (s->blocks != 0 || s->freefrags != 0)
-			fprintf(out, " (%lu bl, %lu ff)",
-				s->blocks, s->freefrags);
+			if (s->blocks != 0 || s->freefrags != 0)
+				txc_fprintf(out, " (%lu bl, %lu ff)",
+					s->blocks, s->freefrags);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		fputc('\n', out);
-	}
+			txc_fprintf(out, "\n");
+		}
 
-	/*
-	 * Note that since a pool can be locked now, these stats might be
-	 * somewhat off if the pool is in active use at the time the stats
-	 * are dumped.  The link fields are protected by the isc_mem_t's
-	 * lock, however, so walking this list and extracting integers from
-	 * stats fields is always safe.
-	 */
-	pool = ISC_LIST_HEAD(ctx->pools);
-	if (pool != NULL) {
-		fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-					    ISC_MSG_POOLSTATS,
-					    "[Pool statistics]\n"));
-		fprintf(out, "%15s %10s %10s %10s %10s %10s %10s %10s %1s\n",
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLNAME, "name"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLSIZE, "size"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLMAXALLOC, "maxalloc"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLALLOCATED, "allocated"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFREECOUNT, "freecount"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFREEMAX, "freemax"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFILLCOUNT, "fillcount"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLGETS, "gets"),
-			"L");
-	}
-	while (pool != NULL) {
-		fprintf(out, "%15s %10lu %10u %10u %10u %10u %10u %10u %s\n",
-			pool->name, (unsigned long) pool->size, pool->maxalloc,
-			pool->allocated, pool->freecount, pool->freemax,
-			pool->fillcount, pool->gets,
-			(pool->lock == NULL ? "N" : "Y"));
-		pool = ISC_LIST_NEXT(pool, link);
-	}
+		/*
+		 * Note that since a pool can be locked now, these stats might be
+		 * somewhat off if the pool is in active use at the time the stats
+		 * are dumped.  The link fields are protected by the isc_mem_t's
+		 * lock, however, so walking this list and extracting integers from
+		 * stats fields is always safe.
+		 */
+		pool = ISC_LIST_HEAD(ctx->pools);
+		if (pool != NULL) {
+			txc_fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+						    ISC_MSG_POOLSTATS,
+						    "[Pool statistics]\n"));
+			txc_fprintf(out, "%15s %10s %10s %10s %10s %10s %10s %10s %1s\n",
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLNAME, "name"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLSIZE, "size"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLMAXALLOC, "maxalloc"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLALLOCATED, "allocated"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFREECOUNT, "freecount"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFREEMAX, "freemax"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFILLCOUNT, "fillcount"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLGETS, "gets"),
+				"L");
+		}
+		while (pool != NULL) {
+			txc_fprintf(out, "%15s %10lu %10u %10u %10u %10u %10u %10u %s\n",
+				pool->name, (unsigned long) pool->size, pool->maxalloc,
+				pool->allocated, pool->freecount, pool->freemax,
+				pool->fillcount, pool->gets,
+				"Transactions");
+			pool = ISC_LIST_NEXT(pool, link);
+		}
 
 #if ISC_MEM_TRACKLINES
-	print_active(ctx, out);
+		print_active(ctx, out);
 #endif
 
-	UNLOCK(&ctx->lock);
+	XACT_END(ctx)
 }
 
 /*
@@ -1235,20 +1237,20 @@
 	REQUIRE(VALID_CONTEXT(ctx));
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	si = isc__mem_allocateunlocked(ctx, size);
+	XACT_BEGIN(ctx)
+		si = isc__mem_allocateunlocked(ctx, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
 	si = isc__mem_allocateunlocked(ctx, size);
-	LOCK(&ctx->lock);
-	if (si != NULL)
-		mem_getstats(ctx, si[-1].u.size);
+	XACT_BEGIN(ctx)
+		if (si != NULL)
+			mem_getstats(ctx, si[-1].u.size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
 #if ISC_MEM_TRACKLINES
-	ADD_TRACE(ctx, si, si[-1].u.size, file, line);
+		ADD_TRACE(ctx, si, si[-1].u.size, file, line);
 #endif
 
-	UNLOCK(&ctx->lock);
+	XACT_END(ctx)
 
 	return (si);
 }
@@ -1265,17 +1267,17 @@
 	size = si->u.size;
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, si, size);
+	XACT_BEGIN(ctx)
+		mem_putunlocked(ctx, si, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
 	mem_put(ctx, si, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, si, size);
+	XACT_BEGIN(ctx)
+		mem_putstats(ctx, si, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
+		DELETE_TRACE(ctx, ptr, size, file, line);
 
-	UNLOCK(&ctx->lock);
+	XACT_END(ctx)
 }
 
 
@@ -1304,11 +1306,9 @@
 void
 isc_mem_setdestroycheck(isc_mem_t *ctx, isc_boolean_t flag) {
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	ctx->checkfree = flag;
-
-	UNLOCK(&ctx->lock);
+	XACT_BEGIN(ctx)
+		ctx->checkfree = flag;
+	XACT_END(ctx)
 }
 
 /*
@@ -1318,11 +1318,11 @@
 void
 isc_mem_setquota(isc_mem_t *ctx, size_t quota) {
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
+	XACT_BEGIN(ctx)
 
-	ctx->quota = quota;
+		ctx->quota = quota;
 
-	UNLOCK(&ctx->lock);
+	XACT_END(ctx)
 }
 
 size_t
@@ -1330,11 +1330,11 @@
 	size_t quota;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
+	XACT_BEGIN(ctx)
 
-	quota = ctx->quota;
+		quota = ctx->quota;
 
-	UNLOCK(&ctx->lock);
+	XACT_END(ctx)
 
 	return (quota);
 }
@@ -1344,11 +1344,11 @@
 	size_t inuse;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
+	XACT_BEGIN(ctx)
 
-	inuse = ctx->inuse;
+		inuse = ctx->inuse;
 
-	UNLOCK(&ctx->lock);
+	XACT_END(ctx)
 
 	return (inuse);
 }
@@ -1364,28 +1364,28 @@
 	REQUIRE(VALID_CONTEXT(ctx));
 	REQUIRE(hiwater >= lowater);
 
-	LOCK(&ctx->lock);
-	oldwater = ctx->water;
-	oldwater_arg = ctx->water_arg;
-	if (water == NULL) {
-		callwater = ctx->hi_called;
-		ctx->water = NULL;
-		ctx->water_arg = NULL;
-		ctx->hi_water = 0;
-		ctx->lo_water = 0;
-		ctx->hi_called = ISC_FALSE;
-	} else {
-		if (ctx->hi_called &&
-		    (ctx->water != water || ctx->water_arg != water_arg ||
-		     ctx->inuse < lowater || lowater == 0U))
-			callwater = ISC_TRUE;
-		ctx->water = water;
-		ctx->water_arg = water_arg;
-		ctx->hi_water = hiwater;
-		ctx->lo_water = lowater;
-		ctx->hi_called = ISC_FALSE;
-	}
-	UNLOCK(&ctx->lock);
+	XACT_BEGIN(ctx)
+		oldwater = ctx->water;
+		oldwater_arg = ctx->water_arg;
+		if (water == NULL) {
+			callwater = ctx->hi_called;
+			ctx->water = NULL;
+			ctx->water_arg = NULL;
+			ctx->hi_water = 0;
+			ctx->lo_water = 0;
+			ctx->hi_called = ISC_FALSE;
+		} else {
+			if (ctx->hi_called &&
+			    (ctx->water != water || ctx->water_arg != water_arg ||
+			     ctx->inuse < lowater || lowater == 0U))
+				callwater = ISC_TRUE;
+			ctx->water = water;
+			ctx->water_arg = water_arg;
+			ctx->hi_water = hiwater;
+			ctx->lo_water = lowater;
+			ctx->hi_called = ISC_FALSE;
+		}
+	XACT_END(ctx)
 
 	if (callwater && oldwater != NULL)
 		(oldwater)(oldwater_arg, ISC_MEM_LOWATER);
@@ -1412,7 +1412,7 @@
 		return (ISC_R_NOMEMORY);
 
 	mpctx->magic = MEMPOOL_MAGIC;
-	mpctx->lock = NULL;
+//	mpctx->lock = NULL;
 	mpctx->mctx = mctx;
 	mpctx->size = size;
 	mpctx->maxalloc = UINT_MAX;
@@ -1428,9 +1428,9 @@
 
 	*mpctxp = mpctx;
 
-	LOCK(&mctx->lock);
-	ISC_LIST_INITANDAPPEND(mctx->pools, mpctx, link);
-	UNLOCK(&mctx->lock);
+	XACT_BEGIN(mctx)
+		ISC_LIST_INITANDAPPEND(mctx->pools, mpctx, link);
+	XACT_END(mctx)
 
 	return (ISC_R_SUCCESS);
 }
@@ -1440,14 +1440,12 @@
 	REQUIRE(name != NULL);
 
 #if ISC_MEMPOOL_NAMES
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
+	XACT_BEGIN(mpctx)
 
-	strncpy(mpctx->name, name, sizeof(mpctx->name) - 1);
-	mpctx->name[sizeof(mpctx->name) - 1] = '\0';
+		strncpy(mpctx->name, name, sizeof(mpctx->name) - 1);
+		mpctx->name[sizeof(mpctx->name) - 1] = '\0';
 
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_END(mpctx)
 #else
 	UNUSED(mpctx);
 	UNUSED(name);
@@ -1475,43 +1473,39 @@
 
 	mctx = mpctx->mctx;
 
-	lock = mpctx->lock;
-
-	if (lock != NULL)
-		LOCK(lock);
+	XACT_BEGIN(mpctx)
 
-	/*
-	 * Return any items on the free list
-	 */
-	LOCK(&mctx->lock);
-	while (mpctx->items != NULL) {
-		INSIST(mpctx->freecount > 0);
-		mpctx->freecount--;
-		item = mpctx->items;
-		mpctx->items = item->next;
+		/*
+		 * Return any items on the free list
+		 */
+		XACT_BEGIN(mctx1)
+			while (mpctx->items != NULL) {
+				INSIST(mpctx->freecount > 0);
+				mpctx->freecount--;
+				item = mpctx->items;
+				mpctx->items = item->next;
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		mem_putunlocked(mctx, item, mpctx->size);
+				mem_putunlocked(mctx, item, mpctx->size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		mem_put(mctx, item, mpctx->size);
-		mem_putstats(mctx, item, mpctx->size);
+				mem_put(mctx, item, mpctx->size);
+				mem_putstats(mctx, item, mpctx->size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-	}
-	UNLOCK(&mctx->lock);
+			}
+		XACT_END(mctx1)
 
-	/*
-	 * Remove our linked list entry from the memory context.
-	 */
-	LOCK(&mctx->lock);
-	ISC_LIST_UNLINK(mctx->pools, mpctx, link);
-	UNLOCK(&mctx->lock);
+		/*
+		 * Remove our linked list entry from the memory context.
+		 */
+		XACT_BEGIN(mctx2)
+			ISC_LIST_UNLINK(mctx->pools, mpctx, link);
+		XACT_END(mctx2)
 
-	mpctx->magic = 0;
+		mpctx->magic = 0;
 
-	isc_mem_put(mpctx->mctx, mpctx, sizeof(isc_mempool_t));
+		isc_mem_put(mpctx->mctx, mpctx, sizeof(isc_mempool_t));
 
-	if (lock != NULL)
-		UNLOCK(lock);
+	XACT_END(mpctx)
 
 	*mpctxp = NULL;
 }
@@ -1519,10 +1513,10 @@
 void
 isc_mempool_associatelock(isc_mempool_t *mpctx, isc_mutex_t *lock) {
 	REQUIRE(VALID_MEMPOOL(mpctx));
-	REQUIRE(mpctx->lock == NULL);
+//	REQUIRE(mpctx->lock == NULL);
 	REQUIRE(lock != NULL);
 
-	mpctx->lock = lock;
+//	mpctx->lock = lock;
 }
 
 void *
@@ -1535,72 +1529,69 @@
 
 	mctx = mpctx->mctx;
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
+	XACT_BEGIN(mpctx_lock)
 
-	/*
-	 * Don't let the caller go over quota
-	 */
-	if (mpctx->allocated >= mpctx->maxalloc) {
-		item = NULL;
-		goto out;
-	}
+		/*
+		 * Don't let the caller go over quota
+		 */
+		if (mpctx->allocated >= mpctx->maxalloc) {
+			item = NULL;
+			goto mpctx_lock_end;
+		}
 
-	/*
-	 * if we have a free list item, return the first here
-	 */
-	item = mpctx->items;
-	if (item != NULL) {
-		mpctx->items = item->next;
-		INSIST(mpctx->freecount > 0);
-		mpctx->freecount--;
-		mpctx->gets++;
-		mpctx->allocated++;
-		goto out;
-	}
+		/*
+		 * if we have a free list item, return the first here
+		 */
+		item = mpctx->items;
+		if (item != NULL) {
+			mpctx->items = item->next;
+			INSIST(mpctx->freecount > 0);
+			mpctx->freecount--;
+			mpctx->gets++;
+			mpctx->allocated++;
+			goto mpctx_lock_end;
+		}
 
-	/*
-	 * We need to dip into the well.  Lock the memory context here and
-	 * fill up our free list.
-	 */
-	LOCK(&mctx->lock);
-	for (i = 0; i < mpctx->fillcount; i++) {
+		/*
+		 * We need to dip into the well.  Lock the memory context here and
+		 * fill up our free list.
+		 */
+		XACT_BEGIN(mctx)
+			for (i = 0; i < mpctx->fillcount; i++) {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		item = mem_getunlocked(mctx, mpctx->size);
+				item = mem_getunlocked(mctx, mpctx->size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		item = mem_get(mctx, mpctx->size);
-		if (item != NULL)
-			mem_getstats(mctx, mpctx->size);
+				item = mem_get(mctx, mpctx->size);
+				if (item != NULL)
+					mem_getstats(mctx, mpctx->size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
+				if (item == NULL)
+					break;
+				item->next = mpctx->items;
+				mpctx->items = item;
+				mpctx->freecount++;
+			}
+		XACT_END(mctx);
+
+		/*
+		 * If we didn't get any items, return NULL.
+		 */
+		item = mpctx->items;
 		if (item == NULL)
-			break;
-		item->next = mpctx->items;
-		mpctx->items = item;
-		mpctx->freecount++;
-	}
-	UNLOCK(&mctx->lock);
+			goto mpctx_lock_end;
 
-	/*
-	 * If we didn't get any items, return NULL.
-	 */
-	item = mpctx->items;
-	if (item == NULL)
-		goto out;
-
-	mpctx->items = item->next;
-	mpctx->freecount--;
-	mpctx->gets++;
-	mpctx->allocated++;
-
- out:
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+		mpctx->items = item->next;
+		mpctx->freecount--;
+		mpctx->gets++;
+		mpctx->allocated++;
+
+	XACT_END(mpctx_lock)
 
 #if ISC_MEM_TRACKLINES
 	if (item != NULL) {
-		LOCK(&mctx->lock);
-		ADD_TRACE(mctx, item, mpctx->size, file, line);
-		UNLOCK(&mctx->lock);
+		XACT_BEGIN(lock)
+			ADD_TRACE(mctx, item, mpctx->size, file, line);
+		XACT_END(lock)
 	}
 #endif /* ISC_MEM_TRACKLINES */
 
@@ -1617,47 +1608,43 @@
 
 	mctx = mpctx->mctx;
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
+	XACT_BEGIN(mpctx_lock)
 
-	INSIST(mpctx->allocated > 0);
-	mpctx->allocated--;
+		INSIST(mpctx->allocated > 0);
+		mpctx->allocated--;
 
 #if ISC_MEM_TRACKLINES
-	LOCK(&mctx->lock);
-	DELETE_TRACE(mctx, mem, mpctx->size, file, line);
-	UNLOCK(&mctx->lock);
+		XACT_BEGIN(lock1)
+			DELETE_TRACE(mctx, mem, mpctx->size, file, line);
+		XACT_END(lock1)
 #endif /* ISC_MEM_TRACKLINES */
 
-	/*
-	 * If our free list is full, return this to the mctx directly.
-	 */
-	if (mpctx->freecount >= mpctx->freemax) {
+		/*
+		 * If our free list is full, return this to the mctx directly.
+		 */
+		if (mpctx->freecount >= mpctx->freemax) {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		LOCK(&mctx->lock);
-		mem_putunlocked(mctx, mem, mpctx->size);
-		UNLOCK(&mctx->lock);
+			XACT_BEGIN(lock2)
+				mem_putunlocked(mctx, mem, mpctx->size);
+			UNLOCK(lock2)
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		mem_put(mctx, mem, mpctx->size);
-		LOCK(&mctx->lock);
-		mem_putstats(mctx, mem, mpctx->size);
-		UNLOCK(&mctx->lock);
+			mem_put(mctx, mem, mpctx->size);
+			XACT_BEGIN(lock2)
+				mem_putstats(mctx, mem, mpctx->size);
+			XACT_END(lock2)
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		if (mpctx->lock != NULL)
-			UNLOCK(mpctx->lock);
-		return;
-	}
+			goto mpctx_lock_end;
+		}
 
-	/*
-	 * Otherwise, attach it to our free list and bump the counter.
-	 */
-	mpctx->freecount++;
-	item = (element *)mem;
-	item->next = mpctx->items;
-	mpctx->items = item;
+		/*
+		 * Otherwise, attach it to our free list and bump the counter.
+		 */
+		mpctx->freecount++;
+		item = (element *)mem;
+		item->next = mpctx->items;
+		mpctx->items = item;
 
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_END(mpctx_lock)
 }
 
 /*
@@ -1668,13 +1655,9 @@
 isc_mempool_setfreemax(isc_mempool_t *mpctx, unsigned int limit) {
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->freemax = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		mpctx->freemax = limit;
+	XACT_END(lock)
 }
 
 unsigned int
@@ -1683,13 +1666,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	freemax = mpctx->freemax;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		freemax = mpctx->freemax;
+	XACT_END(lock)
 
 	return (freemax);
 }
@@ -1700,13 +1679,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	freecount = mpctx->freecount;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		freecount = mpctx->freecount;
+	XACT_END(lock)
 
 	return (freecount);
 }
@@ -1717,13 +1692,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->maxalloc = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		mpctx->maxalloc = limit;
+	XACT_END(lock)
 }
 
 unsigned int
@@ -1732,13 +1703,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	maxalloc = mpctx->maxalloc;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		maxalloc = mpctx->maxalloc;
+	XACT_END(lock)
 
 	return (maxalloc);
 }
@@ -1749,13 +1716,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	allocated = mpctx->allocated;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		allocated = mpctx->allocated;
+	XACT_END(lock)
 
 	return (allocated);
 }
@@ -1765,13 +1728,9 @@
 	REQUIRE(limit > 0);
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->fillcount = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		mpctx->fillcount = limit;
+	XACT_END(lock)
 }
 
 unsigned int
@@ -1780,13 +1739,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	fillcount = mpctx->fillcount;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	XACT_BEGIN(lock)
+		fillcount = mpctx->fillcount;
+	XACT_END(lock)
 
 	return (fillcount);
 }
