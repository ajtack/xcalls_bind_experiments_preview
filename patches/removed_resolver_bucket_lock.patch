Only in bind-modified: isc-config.sh
diff -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' --recursive bind-9.3.5-P2/lib/dns/resolver.c bind-modified/lib/dns/resolver.c
271d270
< 	isc_mutex_t			lock;
817,823c816,820
< 	LOCK(&res->buckets[fctx->bucketnum].lock);
< 
< 	fctx->state = fetchstate_done;
< 	fctx->attributes &= ~FCTX_ATTR_ADDRWAIT;
< 	fctx_sendevents(fctx, result);
< 
< 	UNLOCK(&res->buckets[fctx->bucketnum].lock);
---
> 	__tm_atomic {
> 		fctx->state = fetchstate_done;
> 		fctx->attributes &= ~FCTX_ATTR_ADDRWAIT;
> 		fctx_sendevents(fctx, result);
> 	}
1609c1606
< 		LOCK(&res->buckets[bucketnum].lock);
---
> 		__tm_atomic {
1616c1613
< 		UNLOCK(&res->buckets[bucketnum].lock);
---
> 		}
2640,2650c2637,2651
< 	LOCK(&res->buckets[bucketnum].lock);
< 
< 	fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
< 
< 	INSIST(fctx->state == fetchstate_active ||
< 	       fctx->state == fetchstate_done);
< 	INSIST(fctx->want_shutdown);
< 
< 	if (fctx->state != fetchstate_done) {
< 		fctx->state = fetchstate_done;
< 		fctx_sendevents(fctx, ISC_R_CANCELED);
---
> 	__tm_atomic {
> 		fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
> 	
> 		INSIST(fctx->state == fetchstate_active ||
> 		fctx->state == fetchstate_done);
> 		INSIST(fctx->want_shutdown);
> 	
> 		if (fctx->state != fetchstate_done) {
> 			fctx->state = fetchstate_done;
> 			fctx_sendevents(fctx, ISC_R_CANCELED);
> 		}
> 	
> 		if (fctx->references == 0 && fctx->pending == 0 &&
> 		fctx->nqueries == 0 && ISC_LIST_EMPTY(fctx->validators))
> 			bucket_empty = fctx_destroy(fctx);
2653,2658d2653
< 	if (fctx->references == 0 && fctx->pending == 0 &&
< 	    fctx->nqueries == 0 && ISC_LIST_EMPTY(fctx->validators))
< 		bucket_empty = fctx_destroy(fctx);
< 
< 	UNLOCK(&res->buckets[bucketnum].lock);
< 
2679c2674
< 	LOCK(&res->buckets[bucketnum].lock);
---
> 	__tm_atomic {
2681,2697c2676,2677
< 	INSIST(fctx->state == fetchstate_init);
< 	if (fctx->want_shutdown) {
< 		/*
< 		 * We haven't started this fctx yet, and we've been requested
< 		 * to shut it down.
< 		 */
< 		fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
< 		fctx->state = fetchstate_done;
< 		fctx_sendevents(fctx, ISC_R_CANCELED);
< 		/*
< 		 * Since we haven't started, we INSIST that we have no
< 		 * pending ADB finds and no pending validations.
< 		 */
< 		INSIST(fctx->pending == 0);
< 		INSIST(fctx->nqueries == 0);
< 		INSIST(ISC_LIST_EMPTY(fctx->validators));
< 		if (fctx->references == 0) {
---
> 		INSIST(fctx->state == fetchstate_init);
> 		if (fctx->want_shutdown) {
2699,2701c2679,2710
< 			 * It's now safe to destroy this fctx.
< 			 */
< 			bucket_empty = fctx_destroy(fctx);
---
> 			* We haven't started this fctx yet, and we've been requested
> 			* to shut it down.
> 			*/
> 			fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
> 			fctx->state = fetchstate_done;
> 			fctx_sendevents(fctx, ISC_R_CANCELED);
> 			/*
> 			* Since we haven't started, we INSIST that we have no
> 			* pending ADB finds and no pending validations.
> 			*/
> 			INSIST(fctx->pending == 0);
> 			INSIST(fctx->nqueries == 0);
> 			INSIST(ISC_LIST_EMPTY(fctx->validators));
> 			if (fctx->references == 0) {
> 				/*
> 				* It's now safe to destroy this fctx.
> 				*/
> 				bucket_empty = fctx_destroy(fctx);
> 			}
> 			done = ISC_TRUE;
> 		} else {
> 			/*
> 			* Normal fctx startup.
> 			*/
> 			fctx->state = fetchstate_active;
> 			/*
> 			* Reset the control event for later use in shutting down
> 			* the fctx.
> 			*/
> 			ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
> 				DNS_EVENT_FETCHCONTROL, fctx_doshutdown, fctx,
> 				NULL, NULL, NULL);
2703,2716d2711
< 		done = ISC_TRUE;
< 	} else {
< 		/*
< 		 * Normal fctx startup.
< 		 */
< 		fctx->state = fetchstate_active;
< 		/*
< 		 * Reset the control event for later use in shutting down
< 		 * the fctx.
< 		 */
< 		ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
< 			       DNS_EVENT_FETCHCONTROL, fctx_doshutdown, fctx,
< 			       NULL, NULL, NULL);
< 	}
2718c2713
< 	UNLOCK(&res->buckets[bucketnum].lock);
---
> 	}
3203,3206c3198,3201
< 	LOCK(&res->buckets[bucketnum].lock);
< 	if (fctx->references == 0 && ISC_LIST_EMPTY(fctx->validators))
< 		bucket_empty = fctx_destroy(fctx);
< 	UNLOCK(&res->buckets[bucketnum].lock);
---
> 	__tm_atomic {
> 		if (fctx->references == 0 && ISC_LIST_EMPTY(fctx->validators))
> 			bucket_empty = fctx_destroy(fctx);
> 	}
3274c3269
< 	LOCK(&fctx->res->buckets[fctx->bucketnum].lock);
---
> 	__tm_atomic {
3276,3289c3271,3309
< 	/*
< 	 * If chaining, we need to make sure that the right result code is
< 	 * returned, and that the rdatasets are bound.
< 	 */
< 	if (vevent->result == ISC_R_SUCCESS &&
< 	    !negative &&
< 	    vevent->rdataset != NULL &&
< 	    CHAINING(vevent->rdataset))
< 	{
< 		if (vevent->rdataset->type == dns_rdatatype_cname)
< 			eresult = DNS_R_CNAME;
< 		else {
< 			INSIST(vevent->rdataset->type == dns_rdatatype_dname);
< 			eresult = DNS_R_DNAME;
---
> 		/*
> 		* If chaining, we need to make sure that the right result code is
> 		* returned, and that the rdatasets are bound.
> 		*/
> 		if (vevent->result == ISC_R_SUCCESS &&
> 		!negative &&
> 		vevent->rdataset != NULL &&
> 		CHAINING(vevent->rdataset))
> 		{
> 			if (vevent->rdataset->type == dns_rdatatype_cname)
> 				eresult = DNS_R_CNAME;
> 			else {
> 				INSIST(vevent->rdataset->type == dns_rdatatype_dname);
> 				eresult = DNS_R_DNAME;
> 			}
> 			chaining = ISC_TRUE;
> 		} else
> 			chaining = ISC_FALSE;
> 	
> 		/*
> 		* Either we're not shutting down, or we are shutting down but want
> 		* to cache the result anyway (if this was a validation started by
> 		* a query with cd set)
> 		*/
> 	
> 		hevent = ISC_LIST_HEAD(fctx->events);
> 		if (hevent != NULL) {
> 			if (!negative && !chaining &&
> 			(fctx->type == dns_rdatatype_any ||
> 			fctx->type == dns_rdatatype_rrsig ||
> 			fctx->type == dns_rdatatype_sig)) {
> 				/*
> 				* Don't bind rdatasets; the caller
> 				* will iterate the node.
> 				*/
> 			} else {
> 				ardataset = hevent->rdataset;
> 				asigrdataset = hevent->sigrdataset;
> 			}
3291,3306c3311,3356
< 		chaining = ISC_TRUE;
< 	} else
< 		chaining = ISC_FALSE;
< 
< 	/*
< 	 * Either we're not shutting down, or we are shutting down but want
< 	 * to cache the result anyway (if this was a validation started by
< 	 * a query with cd set)
< 	 */
< 
< 	hevent = ISC_LIST_HEAD(fctx->events);
< 	if (hevent != NULL) {
< 		if (!negative && !chaining &&
< 		    (fctx->type == dns_rdatatype_any ||
< 		     fctx->type == dns_rdatatype_rrsig ||
< 		     fctx->type == dns_rdatatype_sig)) {
---
> 	
> 		if (vevent->result != ISC_R_SUCCESS) {
> 			FCTXTRACE("validation failed");
> 			result = ISC_R_NOTFOUND;
> 			if (vevent->rdataset != NULL)
> 				result = dns_db_findnode(fctx->cache, vevent->name,
> 							ISC_TRUE, &node);
> 			if (result == ISC_R_SUCCESS)
> 				(void)dns_db_deleterdataset(fctx->cache, node, NULL,
> 							vevent->type, 0);
> 			if (result == ISC_R_SUCCESS && vevent->sigrdataset != NULL)
> 				(void)dns_db_deleterdataset(fctx->cache, node, NULL,
> 							dns_rdatatype_rrsig,
> 							vevent->type);
> 			if (result == ISC_R_SUCCESS)
> 				dns_db_detachnode(fctx->cache, &node);
> 			result = vevent->result;
> 			add_bad(fctx, addrinfo, result);
> 			isc_event_free(&event);
> 			INSIST(fctx->validator == NULL);
> 			fctx->validator = ISC_LIST_HEAD(fctx->validators);
> 			if (fctx->validator != NULL) {
> 				dns_validator_send(fctx->validator);
> 			} else if (sentresponse)
> 				fctx_done(fctx, result);	/* Locks bucket. */
> 			else
> 				fctx_try(fctx);			/* Locks bucket. */
> 			return;
> 		}
> 	
> 		isc_stdtime_get(&now);
> 	
> 		if (negative) {
> 			dns_rdatatype_t covers;
> 			FCTXTRACE("nonexistence validation OK");
> 	
> 			if (fctx->rmessage->rcode == dns_rcode_nxdomain)
> 				covers = dns_rdatatype_any;
> 			else
> 				covers = fctx->type;
> 	
> 			result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE,
> 						&node);
> 			if (result != ISC_R_SUCCESS)
> 				goto noanswer_response;
> 	
3308,3313c3358,3372
< 			 * Don't bind rdatasets; the caller
< 			 * will iterate the node.
< 			 */
< 		} else {
< 			ardataset = hevent->rdataset;
< 			asigrdataset = hevent->sigrdataset;
---
> 			* If we are asking for a SOA record set the cache time
> 			* to zero to facilitate locating the containing zone of
> 			* a arbitary zone.
> 			*/
> 			ttl = fctx->res->view->maxncachettl;
> 			if (fctx->type == dns_rdatatype_soa &&
> 			covers == dns_rdatatype_any)
> 				ttl = 0;
> 	
> 			result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
> 						covers, now, ttl,
> 						ardataset, &eresult);
> 			if (result != ISC_R_SUCCESS)
> 				goto noanswer_response;
> 			goto answer_response;
3315,3359c3374,3392
< 	}
< 
< 	if (vevent->result != ISC_R_SUCCESS) {
< 		FCTXTRACE("validation failed");
< 		result = ISC_R_NOTFOUND;
< 		if (vevent->rdataset != NULL)
< 			result = dns_db_findnode(fctx->cache, vevent->name,
< 						 ISC_TRUE, &node);
< 		if (result == ISC_R_SUCCESS)
< 			(void)dns_db_deleterdataset(fctx->cache, node, NULL,
< 						    vevent->type, 0);
< 		if (result == ISC_R_SUCCESS && vevent->sigrdataset != NULL)
< 			(void)dns_db_deleterdataset(fctx->cache, node, NULL,
< 						    dns_rdatatype_rrsig,
< 						    vevent->type);
< 		if (result == ISC_R_SUCCESS)
< 			dns_db_detachnode(fctx->cache, &node);
< 		result = vevent->result;
< 		add_bad(fctx, addrinfo, result);
< 		isc_event_free(&event);
< 		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
< 		INSIST(fctx->validator == NULL);
< 		fctx->validator = ISC_LIST_HEAD(fctx->validators);
< 		if (fctx->validator != NULL) {
< 			dns_validator_send(fctx->validator);
< 		} else if (sentresponse)
< 			fctx_done(fctx, result);	/* Locks bucket. */
< 		else
< 			fctx_try(fctx);			/* Locks bucket. */
< 		return;
< 	}
< 
< 	isc_stdtime_get(&now);
< 
< 	if (negative) {
< 		dns_rdatatype_t covers;
< 		FCTXTRACE("nonexistence validation OK");
< 
< 		if (fctx->rmessage->rcode == dns_rcode_nxdomain)
< 			covers = dns_rdatatype_any;
< 		else
< 			covers = fctx->type;
< 
< 		result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE,
< 					 &node);
---
> 	
> 		FCTXTRACE("validation OK");
> 	
> 		if (vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF] != NULL) {
> 	
> 			result = dns_rdataset_addnoqname(vevent->rdataset,
> 					vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF]);
> 			RUNTIME_CHECK(result == ISC_R_SUCCESS);
> 			INSIST(vevent->sigrdataset != NULL);
> 			vevent->sigrdataset->ttl = vevent->rdataset->ttl;
> 		}
> 	
> 		/*
> 		* The data was already cached as pending data.
> 		* Re-cache it as secure and bind the cached
> 		* rdatasets to the first event on the fetch
> 		* event list.
> 		*/
> 		result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE, &node);
3362,3412c3395
< 
< 		/*
< 		 * If we are asking for a SOA record set the cache time
< 		 * to zero to facilitate locating the containing zone of
< 		 * a arbitary zone.
< 		 */
< 		ttl = fctx->res->view->maxncachettl;
< 		if (fctx->type == dns_rdatatype_soa &&
< 		    covers == dns_rdatatype_any)
< 			ttl = 0;
< 
< 		result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
< 					   covers, now, ttl,
< 					   ardataset, &eresult);
< 		if (result != ISC_R_SUCCESS)
< 			goto noanswer_response;
< 		goto answer_response;
< 	}
< 
< 	FCTXTRACE("validation OK");
< 
< 	if (vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF] != NULL) {
< 
< 		result = dns_rdataset_addnoqname(vevent->rdataset,
< 				   vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF]);
< 		RUNTIME_CHECK(result == ISC_R_SUCCESS);
< 		INSIST(vevent->sigrdataset != NULL);
< 		vevent->sigrdataset->ttl = vevent->rdataset->ttl;
< 	}
< 
< 	/*
< 	 * The data was already cached as pending data.
< 	 * Re-cache it as secure and bind the cached
< 	 * rdatasets to the first event on the fetch
< 	 * event list.
< 	 */
< 	result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE, &node);
< 	if (result != ISC_R_SUCCESS)
< 		goto noanswer_response;
< 
< 	result = dns_db_addrdataset(fctx->cache, node, NULL, now,
< 				    vevent->rdataset, 0, ardataset);
< 	if (result != ISC_R_SUCCESS &&
< 	    result != DNS_R_UNCHANGED)
< 		goto noanswer_response;
< 	if (ardataset != NULL && ardataset->type == 0) {
< 		if (NXDOMAIN(ardataset))
< 			eresult = DNS_R_NCACHENXDOMAIN;
< 		else
< 			eresult = DNS_R_NCACHENXRRSET;
< 	} else if (vevent->sigrdataset != NULL) {
---
> 	
3414,3415c3397
< 					    vevent->sigrdataset, 0,
< 					    asigrdataset);
---
> 					vevent->rdataset, 0, ardataset);
3417c3399
< 		    result != DNS_R_UNCHANGED)
---
> 		result != DNS_R_UNCHANGED)
3419,3437c3401,3441
< 	}
< 
< 	if (sentresponse) {
< 		/*
< 		 * If we only deferred the destroy because we wanted to cache
< 		 * the data, destroy now.
< 		 */
< 		dns_db_detachnode(fctx->cache, &node);
< 		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
< 		if (SHUTTINGDOWN(fctx))
< 			maybe_destroy(fctx);	/* Locks bucket. */
< 		goto cleanup_event;
< 	}
< 
< 	if (!ISC_LIST_EMPTY(fctx->validators)) {
< 		INSIST(!negative);
< 		INSIST(fctx->type == dns_rdatatype_any ||
< 		       fctx->type == dns_rdatatype_rrsig ||
< 		       fctx->type == dns_rdatatype_sig);
---
> 		if (ardataset != NULL && ardataset->type == 0) {
> 			if (NXDOMAIN(ardataset))
> 				eresult = DNS_R_NCACHENXDOMAIN;
> 			else
> 				eresult = DNS_R_NCACHENXRRSET;
> 		} else if (vevent->sigrdataset != NULL) {
> 			result = dns_db_addrdataset(fctx->cache, node, NULL, now,
> 						vevent->sigrdataset, 0,
> 						asigrdataset);
> 			if (result != ISC_R_SUCCESS &&
> 			result != DNS_R_UNCHANGED)
> 				goto noanswer_response;
> 		}
> 	
> 		if (sentresponse) {
> 			/*
> 			* If we only deferred the destroy because we wanted to cache
> 			* the data, destroy now.
> 			*/
> 			dns_db_detachnode(fctx->cache, &node);
> 			if (SHUTTINGDOWN(fctx))
> 				maybe_destroy(fctx);	/* Locks bucket. */
> 			goto cleanup_event;
> 		}
> 	
> 		if (!ISC_LIST_EMPTY(fctx->validators)) {
> 			INSIST(!negative);
> 			INSIST(fctx->type == dns_rdatatype_any ||
> 			fctx->type == dns_rdatatype_rrsig ||
> 			fctx->type == dns_rdatatype_sig);
> 			/*
> 			* Don't send a response yet - we have
> 			* more rdatasets that still need to
> 			* be validated.
> 			*/
> 			dns_db_detachnode(fctx->cache, &node);
> 			dns_validator_send(ISC_LIST_HEAD(fctx->validators));
> 			goto cleanup_event;
> 		}
> 	
> answer_response:
3439,3469c3443,3455
< 		 * Don't send a response yet - we have
< 		 * more rdatasets that still need to
< 		 * be validated.
< 		 */
< 		dns_db_detachnode(fctx->cache, &node);
< 		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
< 		dns_validator_send(ISC_LIST_HEAD(fctx->validators));
< 		goto cleanup_event;
< 	}
< 
<  answer_response:
< 	/*
< 	 * Cache any NS/NSEC records that happened to be validated.
< 	 */
< 	result = dns_message_firstname(fctx->rmessage, DNS_SECTION_AUTHORITY);
< 	while (result == ISC_R_SUCCESS) {
< 		name = NULL;
< 		dns_message_currentname(fctx->rmessage, DNS_SECTION_AUTHORITY,
< 					&name);
< 		for (rdataset = ISC_LIST_HEAD(name->list);
< 		     rdataset != NULL;
< 		     rdataset = ISC_LIST_NEXT(rdataset, link)) {
< 			if ((rdataset->type != dns_rdatatype_ns &&
< 			     rdataset->type != dns_rdatatype_nsec) ||
< 			    rdataset->trust != dns_trust_secure)
< 				continue;
< 			for (sigrdataset = ISC_LIST_HEAD(name->list);
< 			     sigrdataset != NULL;
< 			     sigrdataset = ISC_LIST_NEXT(sigrdataset, link)) {
< 				if (sigrdataset->type != dns_rdatatype_rrsig ||
< 				    sigrdataset->covers != rdataset->type)
---
> 		* Cache any NS/NSEC records that happened to be validated.
> 		*/
> 		result = dns_message_firstname(fctx->rmessage, DNS_SECTION_AUTHORITY);
> 		while (result == ISC_R_SUCCESS) {
> 			name = NULL;
> 			dns_message_currentname(fctx->rmessage, DNS_SECTION_AUTHORITY,
> 						&name);
> 			for (rdataset = ISC_LIST_HEAD(name->list);
> 			rdataset != NULL;
> 			rdataset = ISC_LIST_NEXT(rdataset, link)) {
> 				if ((rdataset->type != dns_rdatatype_ns &&
> 				rdataset->type != dns_rdatatype_nsec) ||
> 				rdataset->trust != dns_trust_secure)
3471c3457,3480
< 				break;
---
> 				for (sigrdataset = ISC_LIST_HEAD(name->list);
> 				sigrdataset != NULL;
> 				sigrdataset = ISC_LIST_NEXT(sigrdataset, link)) {
> 					if (sigrdataset->type != dns_rdatatype_rrsig ||
> 					sigrdataset->covers != rdataset->type)
> 						continue;
> 					break;
> 				}
> 				if (sigrdataset == NULL ||
> 				sigrdataset->trust != dns_trust_secure)
> 					continue;
> 				result = dns_db_findnode(fctx->cache, name, ISC_TRUE,
> 							&nsnode);
> 				if (result != ISC_R_SUCCESS)
> 					continue;
> 	
> 				result = dns_db_addrdataset(fctx->cache, nsnode, NULL,
> 							now, rdataset, 0, NULL);
> 				if (result == ISC_R_SUCCESS)
> 					result = dns_db_addrdataset(fctx->cache, nsnode,
> 								NULL, now,
> 								sigrdataset, 0,
> 								NULL);
> 				dns_db_detachnode(fctx->cache, &nsnode);
3473,3488c3482,3502
< 			if (sigrdataset == NULL ||
< 			    sigrdataset->trust != dns_trust_secure)
< 				continue;
< 			result = dns_db_findnode(fctx->cache, name, ISC_TRUE,
< 						 &nsnode);
< 			if (result != ISC_R_SUCCESS)
< 				continue;
< 
< 			result = dns_db_addrdataset(fctx->cache, nsnode, NULL,
< 						    now, rdataset, 0, NULL);
< 			if (result == ISC_R_SUCCESS)
< 				result = dns_db_addrdataset(fctx->cache, nsnode,
< 							    NULL, now,
< 							    sigrdataset, 0,
< 							    NULL);
< 			dns_db_detachnode(fctx->cache, &nsnode);
---
> 			result = dns_message_nextname(fctx->rmessage,
> 						DNS_SECTION_AUTHORITY);
> 		}
> 	
> 		result = ISC_R_SUCCESS;
> 	
> 		/*
> 		* Respond with an answer, positive or negative,
> 		* as opposed to an error.  'node' must be non-NULL.
> 		*/
> 	
> 		fctx->attributes |= FCTX_ATTR_HAVEANSWER;
> 	
> 		if (hevent != NULL) {
> 			hevent->result = eresult;
> 			RUNTIME_CHECK(dns_name_copy(vevent->name,
> 				dns_fixedname_name(&hevent->foundname), NULL)
> 				== ISC_R_SUCCESS);
> 			dns_db_attach(fctx->cache, &hevent->db);
> 			dns_db_transfernode(fctx->cache, &node, &hevent->node);
> 			clone_results(fctx);
3490,3511d3503
< 		result = dns_message_nextname(fctx->rmessage,
< 					      DNS_SECTION_AUTHORITY);
< 	}
< 
< 	result = ISC_R_SUCCESS;
< 
< 	/*
< 	 * Respond with an answer, positive or negative,
< 	 * as opposed to an error.  'node' must be non-NULL.
< 	 */
< 
< 	fctx->attributes |= FCTX_ATTR_HAVEANSWER;
< 
< 	if (hevent != NULL) {
< 		hevent->result = eresult;
< 		RUNTIME_CHECK(dns_name_copy(vevent->name,
< 			      dns_fixedname_name(&hevent->foundname), NULL)
< 			      == ISC_R_SUCCESS);
< 		dns_db_attach(fctx->cache, &hevent->db);
< 		dns_db_transfernode(fctx->cache, &node, &hevent->node);
< 		clone_results(fctx);
< 	}
3514,3515c3506,3507
< 	if (node != NULL)
< 		dns_db_detachnode(fctx->cache, &node);
---
> 		if (node != NULL)
> 			dns_db_detachnode(fctx->cache, &node);
3517c3509
< 	UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
---
> 	}
3899c3891
< 	LOCK(&fctx->res->buckets[fctx->bucketnum].lock);
---
> 	__tm_atomic {
3901,3912c3893,3906
< 	for (section = DNS_SECTION_ANSWER;
< 	     section <= DNS_SECTION_ADDITIONAL;
< 	     section++) {
< 		result = dns_message_firstname(fctx->rmessage, section);
< 		while (result == ISC_R_SUCCESS) {
< 			name = NULL;
< 			dns_message_currentname(fctx->rmessage, section,
< 						&name);
< 			if ((name->attributes & DNS_NAMEATTR_CACHE) != 0) {
< 				result = cache_name(fctx, name, addrinfo, now);
< 				if (result != ISC_R_SUCCESS)
< 					break;
---
> 		for (section = DNS_SECTION_ANSWER;
> 		section <= DNS_SECTION_ADDITIONAL;
> 		section++) {
> 			result = dns_message_firstname(fctx->rmessage, section);
> 			while (result == ISC_R_SUCCESS) {
> 				name = NULL;
> 				dns_message_currentname(fctx->rmessage, section,
> 							&name);
> 				if ((name->attributes & DNS_NAMEATTR_CACHE) != 0) {
> 					result = cache_name(fctx, name, addrinfo, now);
> 					if (result != ISC_R_SUCCESS)
> 						break;
> 				}
> 				result = dns_message_nextname(fctx->rmessage, section);
3914c3908,3909
< 			result = dns_message_nextname(fctx->rmessage, section);
---
> 			if (result != ISC_R_NOMORE)
> 				break;
3916,3920c3911,3912
< 		if (result != ISC_R_NOMORE)
< 			break;
< 	}
< 	if (result == ISC_R_NOMORE)
< 		result = ISC_R_SUCCESS;
---
> 		if (result == ISC_R_NOMORE)
> 			result = ISC_R_SUCCESS;
3922c3914
< 	UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
---
> 	}
4071c4063
< 	LOCK(&res->buckets[fctx->bucketnum].lock);
---
> 	__tm_atomic {
4073,4116c4065,4109
< 	adbp = NULL;
< 	aname = NULL;
< 	anodep = NULL;
< 	ardataset = NULL;
< 	if (!HAVE_ANSWER(fctx)) {
< 		event = ISC_LIST_HEAD(fctx->events);
< 		if (event != NULL) {
< 			adbp = &event->db;
< 			aname = dns_fixedname_name(&event->foundname);
< 			result = dns_name_copy(name, aname, NULL);
< 			if (result != ISC_R_SUCCESS)
< 				goto unlock;
< 			anodep = &event->node;
< 			ardataset = event->rdataset;
< 		}
< 	} else
< 		event = NULL;
< 
< 	result = dns_db_findnode(fctx->cache, name, ISC_TRUE, &node);
< 	if (result != ISC_R_SUCCESS)
< 		goto unlock;
< 
< 	/*
< 	 * If we are asking for a SOA record set the cache time
< 	 * to zero to facilitate locating the containing zone of
< 	 * a arbitary zone.
< 	 */
< 	ttl = fctx->res->view->maxncachettl;
< 	if (fctx->type == dns_rdatatype_soa &&
< 	    covers == dns_rdatatype_any)
< 		ttl = 0;
< 
< 	result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
< 				   covers, now, ttl, ardataset, &eresult);
< 	if (result != ISC_R_SUCCESS)
< 		goto unlock;
< 
< 	if (!HAVE_ANSWER(fctx)) {
< 		fctx->attributes |= FCTX_ATTR_HAVEANSWER;
< 		if (event != NULL) {
< 			event->result = eresult;
< 			dns_db_attach(fctx->cache, adbp);
< 			dns_db_transfernode(fctx->cache, &node, anodep);
< 			clone_results(fctx);
---
> 		adbp = NULL;
> 		aname = NULL;
> 		anodep = NULL;
> 		ardataset = NULL;
> 		if (!HAVE_ANSWER(fctx)) {
> 			event = ISC_LIST_HEAD(fctx->events);
> 			if (event != NULL) {
> 				adbp = &event->db;
> 				aname = dns_fixedname_name(&event->foundname);
> 				result = dns_name_copy(name, aname, NULL);
> 				if (result != ISC_R_SUCCESS)
> 					goto unlock;
> 				anodep = &event->node;
> 				ardataset = event->rdataset;
> 			}
> 		} else
> 			event = NULL;
> 	
> 		result = dns_db_findnode(fctx->cache, name, ISC_TRUE, &node);
> 		if (result != ISC_R_SUCCESS)
> 			goto unlock;
> 	
> 		/*
> 		* If we are asking for a SOA record set the cache time
> 		* to zero to facilitate locating the containing zone of
> 		* a arbitary zone.
> 		*/
> 		ttl = fctx->res->view->maxncachettl;
> 		if (fctx->type == dns_rdatatype_soa &&
> 		covers == dns_rdatatype_any)
> 			ttl = 0;
> 	
> 		result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
> 					covers, now, ttl, ardataset, &eresult);
> 		if (result != ISC_R_SUCCESS)
> 			goto unlock;
> 	
> 		if (!HAVE_ANSWER(fctx)) {
> 			fctx->attributes |= FCTX_ATTR_HAVEANSWER;
> 			if (event != NULL) {
> 				event->result = eresult;
> 				dns_db_attach(fctx->cache, adbp);
> 				dns_db_transfernode(fctx->cache, &node, anodep);
> 				clone_results(fctx);
> 			}
4117a4111
> unlock:
4120,4122d4113
<  unlock:
< 	UNLOCK(&res->buckets[fctx->bucketnum].lock);
< 
5140,5142c5131,5133
< 			LOCK(&res->buckets[bucketnum].lock);
< 			locked = ISC_TRUE;
< 			fctx->references++;
---
> 			__tm_atomic {
> 				fctx->references++;
> 			}
5153,5160c5144,5151
< 	if (!locked)
< 		LOCK(&res->buckets[bucketnum].lock);
< 	fctx->references--;
< 	if (fctx->references == 0)
< 		bucket_empty = fctx_destroy(fctx);
< 	UNLOCK(&res->buckets[bucketnum].lock);
< 	if (bucket_empty)
< 		empty_bucket(res);
---
> 	
> 	__tm_atomic {
> 		fctx->references--;
> 		if (fctx->references == 0)
> 			bucket_empty = fctx_destroy(fctx);
> 		if (bucket_empty)
> 			empty_bucket(res);
> 	}
5825,5827c5816,5818
< 		LOCK(&fctx->res->buckets[fctx->bucketnum].lock);
< 		fctx->references++;
< 		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
---
> 		__tm_atomic {
> 			fctx->references++;
> 		}
5864d5854
< 		DESTROYLOCK(&res->buckets[i].lock);
5977,5979d5966
< 		result = isc_mutex_init(&res->buckets[i].lock);
< 		if (result != ISC_R_SUCCESS)
< 			goto cleanup_buckets;
5983d5969
< 			DESTROYLOCK(&res->buckets[i].lock);
6062d6047
< 		DESTROYLOCK(&res->buckets[i].lock);
6251,6269c6236,6255
< 			LOCK(&res->buckets[i].lock);
< 			for (fctx = ISC_LIST_HEAD(res->buckets[i].fctxs);
< 			     fctx != NULL;
< 			     fctx = ISC_LIST_NEXT(fctx, link))
< 				fctx_shutdown(fctx);
< 			if (res->dispatchv4 != NULL) {
< 				sock = dns_dispatch_getsocket(res->dispatchv4);
< 				isc_socket_cancel(sock, res->buckets[i].task,
< 						  ISC_SOCKCANCEL_ALL);
< 			}
< 			if (res->dispatchv6 != NULL) {
< 				sock = dns_dispatch_getsocket(res->dispatchv6);
< 				isc_socket_cancel(sock, res->buckets[i].task,
< 						  ISC_SOCKCANCEL_ALL);
< 			}
< 			res->buckets[i].exiting = ISC_TRUE;
< 			if (ISC_LIST_EMPTY(res->buckets[i].fctxs)) {
< 				INSIST(res->activebuckets > 0);
< 				res->activebuckets--;
---
> 			__tm_atomic {
> 				for (fctx = ISC_LIST_HEAD(res->buckets[i].fctxs);
> 				fctx != NULL;
> 				fctx = ISC_LIST_NEXT(fctx, link))
> 					fctx_shutdown(fctx);
> 				if (res->dispatchv4 != NULL) {
> 					sock = dns_dispatch_getsocket(res->dispatchv4);
> 					isc_socket_cancel(sock, res->buckets[i].task,
> 							ISC_SOCKCANCEL_ALL);
> 				}
> 				if (res->dispatchv6 != NULL) {
> 					sock = dns_dispatch_getsocket(res->dispatchv6);
> 					isc_socket_cancel(sock, res->buckets[i].task,
> 							ISC_SOCKCANCEL_ALL);
> 				}
> 				res->buckets[i].exiting = ISC_TRUE;
> 				if (ISC_LIST_EMPTY(res->buckets[i].fctxs)) {
> 					INSIST(res->activebuckets > 0);
> 					res->activebuckets--;
> 				}
6271d6256
< 			UNLOCK(&res->buckets[i].lock);
6379,6391c6364,6367
< 	LOCK(&res->buckets[bucketnum].lock);
< 
< 	if (res->buckets[bucketnum].exiting) {
< 		result = ISC_R_SHUTTINGDOWN;
< 		goto unlock;
< 	}
< 
< 	if ((options & DNS_FETCHOPT_UNSHARED) == 0) {
< 		for (fctx = ISC_LIST_HEAD(res->buckets[bucketnum].fctxs);
< 		     fctx != NULL;
< 		     fctx = ISC_LIST_NEXT(fctx, link)) {
< 			if (fctx_match(fctx, name, type, options))
< 				break;
---
> 	__tm_atomic {
> 	
> 		if (res->buckets[bucketnum].exiting) {
> 			result = ISC_R_SHUTTINGDOWN;
6393,6426c6369,6378
< 	}
< 
< 	/*
< 	 * If we didn't have a fetch, would attach to a done fetch, this
< 	 * fetch has already cloned its results, or if the fetch has gone
< 	 * "idle" (no one was interested in it), we need to start a new
< 	 * fetch instead of joining with the existing one.
< 	 */
< 	if (fctx == NULL ||
< 	    fctx->state == fetchstate_done ||
< 	    fctx->cloned ||
< 	    ISC_LIST_EMPTY(fctx->events)) {
< 		fctx = NULL;
< 		result = fctx_create(res, name, type, domain, nameservers,
< 				     options, bucketnum, &fctx);
< 		if (result != ISC_R_SUCCESS)
< 			goto unlock;
< 		new_fctx = ISC_TRUE;
< 	}
< 
< 	result = fctx_join(fctx, task, action, arg,
< 			   rdataset, sigrdataset, fetch);
< 	if (new_fctx) {
< 		if (result == ISC_R_SUCCESS) {
< 			/*
< 			 * Launch this fctx.
< 			 */
< 			event = &fctx->control_event;
< 			ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
< 				       DNS_EVENT_FETCHCONTROL,
< 				       fctx_start, fctx, NULL,
< 				       NULL, NULL);
< 			isc_task_send(res->buckets[bucketnum].task, &event);
< 		} else {
---
> 		else {
> 			if ((options & DNS_FETCHOPT_UNSHARED) == 0) {
> 				for (fctx = ISC_LIST_HEAD(res->buckets[bucketnum].fctxs);
> 				fctx != NULL;
> 				fctx = ISC_LIST_NEXT(fctx, link)) {
> 					if (fctx_match(fctx, name, type, options))
> 						break;
> 				}
> 			}
> 		
6428,6431c6380,6417
< 			 * We don't care about the result of fctx_destroy()
< 			 * since we know we're not exiting.
< 			 */
< 			(void)fctx_destroy(fctx);
---
> 			* If we didn't have a fetch, would attach to a done fetch, this
> 			* fetch has already cloned its results, or if the fetch has gone
> 			* "idle" (no one was interested in it), we need to start a new
> 			* fetch instead of joining with the existing one.
> 			*/
> 			if (fctx == NULL ||
> 			fctx->state == fetchstate_done ||
> 			fctx->cloned ||
> 			ISC_LIST_EMPTY(fctx->events)) {
> 				fctx = NULL;
> 				result = fctx_create(res, name, type, domain, nameservers,
> 						options, bucketnum, &fctx);
> 				if (result == ISC_R_SUCCESS) {
> 					new_fctx = ISC_TRUE;
> 				}
> 			}
> 		
> 			result = fctx_join(fctx, task, action, arg,
> 					rdataset, sigrdataset, fetch);
> 			if (new_fctx) {
> 				if (result == ISC_R_SUCCESS) {
> 					/*
> 					* Launch this fctx.
> 					*/
> 					event = &fctx->control_event;
> 					ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
> 						DNS_EVENT_FETCHCONTROL,
> 						fctx_start, fctx, NULL,
> 						NULL, NULL);
> 					isc_task_send(res->buckets[bucketnum].task, &event);
> 				} else {
> 					/*
> 					* We don't care about the result of fctx_destroy()
> 					* since we know we're not exiting.
> 					*/
> 					(void)fctx_destroy(fctx);
> 				}
> 			}
6435,6437d6420
<  unlock:
< 	UNLOCK(&res->buckets[bucketnum].lock);
< 
6461c6444
< 	LOCK(&res->buckets[fctx->bucketnum].lock);
---
> 	__tm_atomic {
6463,6476c6446,6460
< 	/*
< 	 * Find the completion event for this fetch (as opposed
< 	 * to those for other fetches that have joined the same
< 	 * fctx) and send it with result = ISC_R_CANCELED.
< 	 */
< 	event = NULL;
< 	if (fctx->state != fetchstate_done) {
< 		for (event = ISC_LIST_HEAD(fctx->events);
< 		     event != NULL;
< 		     event = next_event) {
< 			next_event = ISC_LIST_NEXT(event, ev_link);
< 			if (event->fetch == fetch) {
< 				ISC_LIST_UNLINK(fctx->events, event, ev_link);
< 				break;
---
> 		/*
> 		* Find the completion event for this fetch (as opposed
> 		* to those for other fetches that have joined the same
> 		* fctx) and send it with result = ISC_R_CANCELED.
> 		*/
> 		event = NULL;
> 		if (fctx->state != fetchstate_done) {
> 			for (event = ISC_LIST_HEAD(fctx->events);
> 			event != NULL;
> 			event = next_event) {
> 				next_event = ISC_LIST_NEXT(event, ev_link);
> 				if (event->fetch == fetch) {
> 					ISC_LIST_UNLINK(fctx->events, event, ev_link);
> 					break;
> 				}
6479,6489c6463,6472
< 	}
< 	if (event != NULL) {
< 		etask = event->ev_sender;
< 		event->ev_sender = fctx;
< 		event->result = ISC_R_CANCELED;
< 		isc_task_sendanddetach(&etask, ISC_EVENT_PTR(&event));
< 	}
< 	/*
< 	 * The fctx continues running even if no fetches remain;
< 	 * the answer is still cached.
< 	 */
---
> 		if (event != NULL) {
> 			etask = event->ev_sender;
> 			event->ev_sender = fctx;
> 			event->result = ISC_R_CANCELED;
> 			isc_task_sendanddetach(&etask, ISC_EVENT_PTR(&event));
> 		}
> 		/*
> 		* The fctx continues running even if no fetches remain;
> 		* the answer is still cached.
> 		*/
6491c6474
< 	UNLOCK(&res->buckets[fctx->bucketnum].lock);
---
> 	}
6513,6531c6496,6497
< 	LOCK(&res->buckets[bucketnum].lock);
< 
< 	/*
< 	 * Sanity check: the caller should have gotten its event before
< 	 * trying to destroy the fetch.
< 	 */
< 	event = NULL;
< 	if (fctx->state != fetchstate_done) {
< 		for (event = ISC_LIST_HEAD(fctx->events);
< 		     event != NULL;
< 		     event = next_event) {
< 			next_event = ISC_LIST_NEXT(event, ev_link);
< 			RUNTIME_CHECK(event->fetch != fetch);
< 		}
< 	}
< 
< 	INSIST(fctx->references > 0);
< 	fctx->references--;
< 	if (fctx->references == 0) {
---
> 	
> 	__tm_atomic {
6533,6543c6499,6514
< 		 * No one cares about the result of this fetch anymore.
< 		 */
< 		if (fctx->pending == 0 && fctx->nqueries == 0 &&
< 		    ISC_LIST_EMPTY(fctx->validators) &&
< 		    SHUTTINGDOWN(fctx)) {
< 			/*
< 			 * This fctx is already shutdown; we were just
< 			 * waiting for the last reference to go away.
< 			 */
< 			bucket_empty = fctx_destroy(fctx);
< 		} else {
---
> 		* Sanity check: the caller should have gotten its event before
> 		* trying to destroy the fetch.
> 		*/
> 		event = NULL;
> 		if (fctx->state != fetchstate_done) {
> 			for (event = ISC_LIST_HEAD(fctx->events);
> 			event != NULL;
> 			event = next_event) {
> 				next_event = ISC_LIST_NEXT(event, ev_link);
> 				RUNTIME_CHECK(event->fetch != fetch);
> 			}
> 		}
> 	
> 		INSIST(fctx->references > 0);
> 		fctx->references--;
> 		if (fctx->references == 0) {
6545,6547c6516,6531
< 			 * Initiate shutdown.
< 			 */
< 			fctx_shutdown(fctx);
---
> 			* No one cares about the result of this fetch anymore.
> 			*/
> 			if (fctx->pending == 0 && fctx->nqueries == 0 &&
> 			ISC_LIST_EMPTY(fctx->validators) &&
> 			SHUTTINGDOWN(fctx)) {
> 				/*
> 				* This fctx is already shutdown; we were just
> 				* waiting for the last reference to go away.
> 				*/
> 				bucket_empty = fctx_destroy(fctx);
> 			} else {
> 				/*
> 				* Initiate shutdown.
> 				*/
> 				fctx_shutdown(fctx);
> 			}
6549d6532
< 	}
6551c6534
< 	UNLOCK(&res->buckets[bucketnum].lock);
---
> 	}
Only in bind-modified/lib/isc: memalloc
Only in bind-modified: output
Only in bind-modified: something
