diff -Naur -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/dns/resolver.c bind-modified/lib/dns/resolver.c
--- bind-9.3.5-P2/lib/dns/resolver.c	2008-07-24 00:00:46.000000000 -0500
+++ bind-modified/lib/dns/resolver.c	2008-10-08 02:20:36.000000000 -0500
@@ -268,7 +268,6 @@
 
 typedef struct fctxbucket {
 	isc_task_t *			task;
-	isc_mutex_t			lock;
 	ISC_LIST(fetchctx_t)		fctxs;
 	isc_boolean_t			exiting;
 } fctxbucket_t;
@@ -814,13 +813,11 @@
 		no_response = ISC_FALSE;
 	fctx_stopeverything(fctx, no_response);
 
-	LOCK(&res->buckets[fctx->bucketnum].lock);
-
-	fctx->state = fetchstate_done;
-	fctx->attributes &= ~FCTX_ATTR_ADDRWAIT;
-	fctx_sendevents(fctx, result);
-
-	UNLOCK(&res->buckets[fctx->bucketnum].lock);
+	__tm_atomic {
+		fctx->state = fetchstate_done;
+		fctx->attributes &= ~FCTX_ATTR_ADDRWAIT;
+		fctx_sendevents(fctx, result);
+	}
 }
 
 static void
@@ -1606,14 +1603,14 @@
 	} else if (SHUTTINGDOWN(fctx) && fctx->pending == 0 &&
 		   fctx->nqueries == 0 && ISC_LIST_EMPTY(fctx->validators)) {
 		bucketnum = fctx->bucketnum;
-		LOCK(&res->buckets[bucketnum].lock);
+		__tm_atomic {
 		/*
 		 * Note that we had to wait until we had the lock before
 		 * looking at fctx->references.
 		 */
 		if (fctx->references == 0)
 			bucket_empty = fctx_destroy(fctx);
-		UNLOCK(&res->buckets[bucketnum].lock);
+		}
 	}
 
 	isc_event_free(&event);
@@ -2637,25 +2634,23 @@
 	 */
 	fctx_stopeverything(fctx, ISC_FALSE);
 
-	LOCK(&res->buckets[bucketnum].lock);
-
-	fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
-
-	INSIST(fctx->state == fetchstate_active ||
-	       fctx->state == fetchstate_done);
-	INSIST(fctx->want_shutdown);
-
-	if (fctx->state != fetchstate_done) {
-		fctx->state = fetchstate_done;
-		fctx_sendevents(fctx, ISC_R_CANCELED);
+	__tm_atomic {
+		fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
+	
+		INSIST(fctx->state == fetchstate_active ||
+		fctx->state == fetchstate_done);
+		INSIST(fctx->want_shutdown);
+	
+		if (fctx->state != fetchstate_done) {
+			fctx->state = fetchstate_done;
+			fctx_sendevents(fctx, ISC_R_CANCELED);
+		}
+	
+		if (fctx->references == 0 && fctx->pending == 0 &&
+		fctx->nqueries == 0 && ISC_LIST_EMPTY(fctx->validators))
+			bucket_empty = fctx_destroy(fctx);
 	}
 
-	if (fctx->references == 0 && fctx->pending == 0 &&
-	    fctx->nqueries == 0 && ISC_LIST_EMPTY(fctx->validators))
-		bucket_empty = fctx_destroy(fctx);
-
-	UNLOCK(&res->buckets[bucketnum].lock);
-
 	if (bucket_empty)
 		empty_bucket(res);
 }
@@ -2676,46 +2671,46 @@
 
 	FCTXTRACE("start");
 
-	LOCK(&res->buckets[bucketnum].lock);
+	__tm_atomic {
 
-	INSIST(fctx->state == fetchstate_init);
-	if (fctx->want_shutdown) {
-		/*
-		 * We haven't started this fctx yet, and we've been requested
-		 * to shut it down.
-		 */
-		fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
-		fctx->state = fetchstate_done;
-		fctx_sendevents(fctx, ISC_R_CANCELED);
-		/*
-		 * Since we haven't started, we INSIST that we have no
-		 * pending ADB finds and no pending validations.
-		 */
-		INSIST(fctx->pending == 0);
-		INSIST(fctx->nqueries == 0);
-		INSIST(ISC_LIST_EMPTY(fctx->validators));
-		if (fctx->references == 0) {
+		INSIST(fctx->state == fetchstate_init);
+		if (fctx->want_shutdown) {
 			/*
-			 * It's now safe to destroy this fctx.
-			 */
-			bucket_empty = fctx_destroy(fctx);
+			* We haven't started this fctx yet, and we've been requested
+			* to shut it down.
+			*/
+			fctx->attributes |= FCTX_ATTR_SHUTTINGDOWN;
+			fctx->state = fetchstate_done;
+			fctx_sendevents(fctx, ISC_R_CANCELED);
+			/*
+			* Since we haven't started, we INSIST that we have no
+			* pending ADB finds and no pending validations.
+			*/
+			INSIST(fctx->pending == 0);
+			INSIST(fctx->nqueries == 0);
+			INSIST(ISC_LIST_EMPTY(fctx->validators));
+			if (fctx->references == 0) {
+				/*
+				* It's now safe to destroy this fctx.
+				*/
+				bucket_empty = fctx_destroy(fctx);
+			}
+			done = ISC_TRUE;
+		} else {
+			/*
+			* Normal fctx startup.
+			*/
+			fctx->state = fetchstate_active;
+			/*
+			* Reset the control event for later use in shutting down
+			* the fctx.
+			*/
+			ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
+				DNS_EVENT_FETCHCONTROL, fctx_doshutdown, fctx,
+				NULL, NULL, NULL);
 		}
-		done = ISC_TRUE;
-	} else {
-		/*
-		 * Normal fctx startup.
-		 */
-		fctx->state = fetchstate_active;
-		/*
-		 * Reset the control event for later use in shutting down
-		 * the fctx.
-		 */
-		ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
-			       DNS_EVENT_FETCHCONTROL, fctx_doshutdown, fctx,
-			       NULL, NULL, NULL);
-	}
 
-	UNLOCK(&res->buckets[bucketnum].lock);
+	}
 
 	if (!done) {
 		isc_result_t result;
@@ -3200,10 +3195,10 @@
 	}
 
 	bucketnum = fctx->bucketnum;
-	LOCK(&res->buckets[bucketnum].lock);
-	if (fctx->references == 0 && ISC_LIST_EMPTY(fctx->validators))
-		bucket_empty = fctx_destroy(fctx);
-	UNLOCK(&res->buckets[bucketnum].lock);
+	__tm_atomic {
+		if (fctx->references == 0 && ISC_LIST_EMPTY(fctx->validators))
+			bucket_empty = fctx_destroy(fctx);
+	}
 
 	if (bucket_empty)
 		empty_bucket(res);
@@ -3271,250 +3266,247 @@
 		goto cleanup_event;
 	}
 
-	LOCK(&fctx->res->buckets[fctx->bucketnum].lock);
+	__tm_atomic {
 
-	/*
-	 * If chaining, we need to make sure that the right result code is
-	 * returned, and that the rdatasets are bound.
-	 */
-	if (vevent->result == ISC_R_SUCCESS &&
-	    !negative &&
-	    vevent->rdataset != NULL &&
-	    CHAINING(vevent->rdataset))
-	{
-		if (vevent->rdataset->type == dns_rdatatype_cname)
-			eresult = DNS_R_CNAME;
-		else {
-			INSIST(vevent->rdataset->type == dns_rdatatype_dname);
-			eresult = DNS_R_DNAME;
+		/*
+		* If chaining, we need to make sure that the right result code is
+		* returned, and that the rdatasets are bound.
+		*/
+		if (vevent->result == ISC_R_SUCCESS &&
+		!negative &&
+		vevent->rdataset != NULL &&
+		CHAINING(vevent->rdataset))
+		{
+			if (vevent->rdataset->type == dns_rdatatype_cname)
+				eresult = DNS_R_CNAME;
+			else {
+				INSIST(vevent->rdataset->type == dns_rdatatype_dname);
+				eresult = DNS_R_DNAME;
+			}
+			chaining = ISC_TRUE;
+		} else
+			chaining = ISC_FALSE;
+	
+		/*
+		* Either we're not shutting down, or we are shutting down but want
+		* to cache the result anyway (if this was a validation started by
+		* a query with cd set)
+		*/
+	
+		hevent = ISC_LIST_HEAD(fctx->events);
+		if (hevent != NULL) {
+			if (!negative && !chaining &&
+			(fctx->type == dns_rdatatype_any ||
+			fctx->type == dns_rdatatype_rrsig ||
+			fctx->type == dns_rdatatype_sig)) {
+				/*
+				* Don't bind rdatasets; the caller
+				* will iterate the node.
+				*/
+			} else {
+				ardataset = hevent->rdataset;
+				asigrdataset = hevent->sigrdataset;
+			}
 		}
-		chaining = ISC_TRUE;
-	} else
-		chaining = ISC_FALSE;
-
-	/*
-	 * Either we're not shutting down, or we are shutting down but want
-	 * to cache the result anyway (if this was a validation started by
-	 * a query with cd set)
-	 */
-
-	hevent = ISC_LIST_HEAD(fctx->events);
-	if (hevent != NULL) {
-		if (!negative && !chaining &&
-		    (fctx->type == dns_rdatatype_any ||
-		     fctx->type == dns_rdatatype_rrsig ||
-		     fctx->type == dns_rdatatype_sig)) {
+	
+		if (vevent->result != ISC_R_SUCCESS) {
+			FCTXTRACE("validation failed");
+			result = ISC_R_NOTFOUND;
+			if (vevent->rdataset != NULL)
+				result = dns_db_findnode(fctx->cache, vevent->name,
+							ISC_TRUE, &node);
+			if (result == ISC_R_SUCCESS)
+				(void)dns_db_deleterdataset(fctx->cache, node, NULL,
+							vevent->type, 0);
+			if (result == ISC_R_SUCCESS && vevent->sigrdataset != NULL)
+				(void)dns_db_deleterdataset(fctx->cache, node, NULL,
+							dns_rdatatype_rrsig,
+							vevent->type);
+			if (result == ISC_R_SUCCESS)
+				dns_db_detachnode(fctx->cache, &node);
+			result = vevent->result;
+			add_bad(fctx, addrinfo, result);
+			isc_event_free(&event);
+			INSIST(fctx->validator == NULL);
+			fctx->validator = ISC_LIST_HEAD(fctx->validators);
+			if (fctx->validator != NULL) {
+				dns_validator_send(fctx->validator);
+			} else if (sentresponse)
+				fctx_done(fctx, result);	/* Locks bucket. */
+			else
+				fctx_try(fctx);			/* Locks bucket. */
+			return;
+		}
+	
+		isc_stdtime_get(&now);
+	
+		if (negative) {
+			dns_rdatatype_t covers;
+			FCTXTRACE("nonexistence validation OK");
+	
+			if (fctx->rmessage->rcode == dns_rcode_nxdomain)
+				covers = dns_rdatatype_any;
+			else
+				covers = fctx->type;
+	
+			result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE,
+						&node);
+			if (result != ISC_R_SUCCESS)
+				goto noanswer_response;
+	
 			/*
-			 * Don't bind rdatasets; the caller
-			 * will iterate the node.
-			 */
-		} else {
-			ardataset = hevent->rdataset;
-			asigrdataset = hevent->sigrdataset;
+			* If we are asking for a SOA record set the cache time
+			* to zero to facilitate locating the containing zone of
+			* a arbitary zone.
+			*/
+			ttl = fctx->res->view->maxncachettl;
+			if (fctx->type == dns_rdatatype_soa &&
+			covers == dns_rdatatype_any)
+				ttl = 0;
+	
+			result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
+						covers, now, ttl,
+						ardataset, &eresult);
+			if (result != ISC_R_SUCCESS)
+				goto noanswer_response;
+			goto answer_response;
 		}
-	}
-
-	if (vevent->result != ISC_R_SUCCESS) {
-		FCTXTRACE("validation failed");
-		result = ISC_R_NOTFOUND;
-		if (vevent->rdataset != NULL)
-			result = dns_db_findnode(fctx->cache, vevent->name,
-						 ISC_TRUE, &node);
-		if (result == ISC_R_SUCCESS)
-			(void)dns_db_deleterdataset(fctx->cache, node, NULL,
-						    vevent->type, 0);
-		if (result == ISC_R_SUCCESS && vevent->sigrdataset != NULL)
-			(void)dns_db_deleterdataset(fctx->cache, node, NULL,
-						    dns_rdatatype_rrsig,
-						    vevent->type);
-		if (result == ISC_R_SUCCESS)
-			dns_db_detachnode(fctx->cache, &node);
-		result = vevent->result;
-		add_bad(fctx, addrinfo, result);
-		isc_event_free(&event);
-		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
-		INSIST(fctx->validator == NULL);
-		fctx->validator = ISC_LIST_HEAD(fctx->validators);
-		if (fctx->validator != NULL) {
-			dns_validator_send(fctx->validator);
-		} else if (sentresponse)
-			fctx_done(fctx, result);	/* Locks bucket. */
-		else
-			fctx_try(fctx);			/* Locks bucket. */
-		return;
-	}
-
-	isc_stdtime_get(&now);
-
-	if (negative) {
-		dns_rdatatype_t covers;
-		FCTXTRACE("nonexistence validation OK");
-
-		if (fctx->rmessage->rcode == dns_rcode_nxdomain)
-			covers = dns_rdatatype_any;
-		else
-			covers = fctx->type;
-
-		result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE,
-					 &node);
+	
+		FCTXTRACE("validation OK");
+	
+		if (vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF] != NULL) {
+	
+			result = dns_rdataset_addnoqname(vevent->rdataset,
+					vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF]);
+			RUNTIME_CHECK(result == ISC_R_SUCCESS);
+			INSIST(vevent->sigrdataset != NULL);
+			vevent->sigrdataset->ttl = vevent->rdataset->ttl;
+		}
+	
+		/*
+		* The data was already cached as pending data.
+		* Re-cache it as secure and bind the cached
+		* rdatasets to the first event on the fetch
+		* event list.
+		*/
+		result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE, &node);
 		if (result != ISC_R_SUCCESS)
 			goto noanswer_response;
-
-		/*
-		 * If we are asking for a SOA record set the cache time
-		 * to zero to facilitate locating the containing zone of
-		 * a arbitary zone.
-		 */
-		ttl = fctx->res->view->maxncachettl;
-		if (fctx->type == dns_rdatatype_soa &&
-		    covers == dns_rdatatype_any)
-			ttl = 0;
-
-		result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
-					   covers, now, ttl,
-					   ardataset, &eresult);
-		if (result != ISC_R_SUCCESS)
-			goto noanswer_response;
-		goto answer_response;
-	}
-
-	FCTXTRACE("validation OK");
-
-	if (vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF] != NULL) {
-
-		result = dns_rdataset_addnoqname(vevent->rdataset,
-				   vevent->proofs[DNS_VALIDATOR_NOQNAMEPROOF]);
-		RUNTIME_CHECK(result == ISC_R_SUCCESS);
-		INSIST(vevent->sigrdataset != NULL);
-		vevent->sigrdataset->ttl = vevent->rdataset->ttl;
-	}
-
-	/*
-	 * The data was already cached as pending data.
-	 * Re-cache it as secure and bind the cached
-	 * rdatasets to the first event on the fetch
-	 * event list.
-	 */
-	result = dns_db_findnode(fctx->cache, vevent->name, ISC_TRUE, &node);
-	if (result != ISC_R_SUCCESS)
-		goto noanswer_response;
-
-	result = dns_db_addrdataset(fctx->cache, node, NULL, now,
-				    vevent->rdataset, 0, ardataset);
-	if (result != ISC_R_SUCCESS &&
-	    result != DNS_R_UNCHANGED)
-		goto noanswer_response;
-	if (ardataset != NULL && ardataset->type == 0) {
-		if (NXDOMAIN(ardataset))
-			eresult = DNS_R_NCACHENXDOMAIN;
-		else
-			eresult = DNS_R_NCACHENXRRSET;
-	} else if (vevent->sigrdataset != NULL) {
+	
 		result = dns_db_addrdataset(fctx->cache, node, NULL, now,
-					    vevent->sigrdataset, 0,
-					    asigrdataset);
+					vevent->rdataset, 0, ardataset);
 		if (result != ISC_R_SUCCESS &&
-		    result != DNS_R_UNCHANGED)
+		result != DNS_R_UNCHANGED)
 			goto noanswer_response;
-	}
-
-	if (sentresponse) {
-		/*
-		 * If we only deferred the destroy because we wanted to cache
-		 * the data, destroy now.
-		 */
-		dns_db_detachnode(fctx->cache, &node);
-		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
-		if (SHUTTINGDOWN(fctx))
-			maybe_destroy(fctx);	/* Locks bucket. */
-		goto cleanup_event;
-	}
-
-	if (!ISC_LIST_EMPTY(fctx->validators)) {
-		INSIST(!negative);
-		INSIST(fctx->type == dns_rdatatype_any ||
-		       fctx->type == dns_rdatatype_rrsig ||
-		       fctx->type == dns_rdatatype_sig);
+		if (ardataset != NULL && ardataset->type == 0) {
+			if (NXDOMAIN(ardataset))
+				eresult = DNS_R_NCACHENXDOMAIN;
+			else
+				eresult = DNS_R_NCACHENXRRSET;
+		} else if (vevent->sigrdataset != NULL) {
+			result = dns_db_addrdataset(fctx->cache, node, NULL, now,
+						vevent->sigrdataset, 0,
+						asigrdataset);
+			if (result != ISC_R_SUCCESS &&
+			result != DNS_R_UNCHANGED)
+				goto noanswer_response;
+		}
+	
+		if (sentresponse) {
+			/*
+			* If we only deferred the destroy because we wanted to cache
+			* the data, destroy now.
+			*/
+			dns_db_detachnode(fctx->cache, &node);
+			if (SHUTTINGDOWN(fctx))
+				maybe_destroy(fctx);	/* Locks bucket. */
+			goto cleanup_event;
+		}
+	
+		if (!ISC_LIST_EMPTY(fctx->validators)) {
+			INSIST(!negative);
+			INSIST(fctx->type == dns_rdatatype_any ||
+			fctx->type == dns_rdatatype_rrsig ||
+			fctx->type == dns_rdatatype_sig);
+			/*
+			* Don't send a response yet - we have
+			* more rdatasets that still need to
+			* be validated.
+			*/
+			dns_db_detachnode(fctx->cache, &node);
+			dns_validator_send(ISC_LIST_HEAD(fctx->validators));
+			goto cleanup_event;
+		}
+	
+answer_response:
 		/*
-		 * Don't send a response yet - we have
-		 * more rdatasets that still need to
-		 * be validated.
-		 */
-		dns_db_detachnode(fctx->cache, &node);
-		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
-		dns_validator_send(ISC_LIST_HEAD(fctx->validators));
-		goto cleanup_event;
-	}
-
- answer_response:
-	/*
-	 * Cache any NS/NSEC records that happened to be validated.
-	 */
-	result = dns_message_firstname(fctx->rmessage, DNS_SECTION_AUTHORITY);
-	while (result == ISC_R_SUCCESS) {
-		name = NULL;
-		dns_message_currentname(fctx->rmessage, DNS_SECTION_AUTHORITY,
-					&name);
-		for (rdataset = ISC_LIST_HEAD(name->list);
-		     rdataset != NULL;
-		     rdataset = ISC_LIST_NEXT(rdataset, link)) {
-			if ((rdataset->type != dns_rdatatype_ns &&
-			     rdataset->type != dns_rdatatype_nsec) ||
-			    rdataset->trust != dns_trust_secure)
-				continue;
-			for (sigrdataset = ISC_LIST_HEAD(name->list);
-			     sigrdataset != NULL;
-			     sigrdataset = ISC_LIST_NEXT(sigrdataset, link)) {
-				if (sigrdataset->type != dns_rdatatype_rrsig ||
-				    sigrdataset->covers != rdataset->type)
+		* Cache any NS/NSEC records that happened to be validated.
+		*/
+		result = dns_message_firstname(fctx->rmessage, DNS_SECTION_AUTHORITY);
+		while (result == ISC_R_SUCCESS) {
+			name = NULL;
+			dns_message_currentname(fctx->rmessage, DNS_SECTION_AUTHORITY,
+						&name);
+			for (rdataset = ISC_LIST_HEAD(name->list);
+			rdataset != NULL;
+			rdataset = ISC_LIST_NEXT(rdataset, link)) {
+				if ((rdataset->type != dns_rdatatype_ns &&
+				rdataset->type != dns_rdatatype_nsec) ||
+				rdataset->trust != dns_trust_secure)
 					continue;
-				break;
+				for (sigrdataset = ISC_LIST_HEAD(name->list);
+				sigrdataset != NULL;
+				sigrdataset = ISC_LIST_NEXT(sigrdataset, link)) {
+					if (sigrdataset->type != dns_rdatatype_rrsig ||
+					sigrdataset->covers != rdataset->type)
+						continue;
+					break;
+				}
+				if (sigrdataset == NULL ||
+				sigrdataset->trust != dns_trust_secure)
+					continue;
+				result = dns_db_findnode(fctx->cache, name, ISC_TRUE,
+							&nsnode);
+				if (result != ISC_R_SUCCESS)
+					continue;
+	
+				result = dns_db_addrdataset(fctx->cache, nsnode, NULL,
+							now, rdataset, 0, NULL);
+				if (result == ISC_R_SUCCESS)
+					result = dns_db_addrdataset(fctx->cache, nsnode,
+								NULL, now,
+								sigrdataset, 0,
+								NULL);
+				dns_db_detachnode(fctx->cache, &nsnode);
 			}
-			if (sigrdataset == NULL ||
-			    sigrdataset->trust != dns_trust_secure)
-				continue;
-			result = dns_db_findnode(fctx->cache, name, ISC_TRUE,
-						 &nsnode);
-			if (result != ISC_R_SUCCESS)
-				continue;
-
-			result = dns_db_addrdataset(fctx->cache, nsnode, NULL,
-						    now, rdataset, 0, NULL);
-			if (result == ISC_R_SUCCESS)
-				result = dns_db_addrdataset(fctx->cache, nsnode,
-							    NULL, now,
-							    sigrdataset, 0,
-							    NULL);
-			dns_db_detachnode(fctx->cache, &nsnode);
+			result = dns_message_nextname(fctx->rmessage,
+						DNS_SECTION_AUTHORITY);
+		}
+	
+		result = ISC_R_SUCCESS;
+	
+		/*
+		* Respond with an answer, positive or negative,
+		* as opposed to an error.  'node' must be non-NULL.
+		*/
+	
+		fctx->attributes |= FCTX_ATTR_HAVEANSWER;
+	
+		if (hevent != NULL) {
+			hevent->result = eresult;
+			RUNTIME_CHECK(dns_name_copy(vevent->name,
+				dns_fixedname_name(&hevent->foundname), NULL)
+				== ISC_R_SUCCESS);
+			dns_db_attach(fctx->cache, &hevent->db);
+			dns_db_transfernode(fctx->cache, &node, &hevent->node);
+			clone_results(fctx);
 		}
-		result = dns_message_nextname(fctx->rmessage,
-					      DNS_SECTION_AUTHORITY);
-	}
-
-	result = ISC_R_SUCCESS;
-
-	/*
-	 * Respond with an answer, positive or negative,
-	 * as opposed to an error.  'node' must be non-NULL.
-	 */
-
-	fctx->attributes |= FCTX_ATTR_HAVEANSWER;
-
-	if (hevent != NULL) {
-		hevent->result = eresult;
-		RUNTIME_CHECK(dns_name_copy(vevent->name,
-			      dns_fixedname_name(&hevent->foundname), NULL)
-			      == ISC_R_SUCCESS);
-		dns_db_attach(fctx->cache, &hevent->db);
-		dns_db_transfernode(fctx->cache, &node, &hevent->node);
-		clone_results(fctx);
-	}
 
  noanswer_response:
-	if (node != NULL)
-		dns_db_detachnode(fctx->cache, &node);
+		if (node != NULL)
+			dns_db_detachnode(fctx->cache, &node);
 
-	UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
+	}
 
 	fctx_done(fctx, result);	/* Locks bucket. */
 
@@ -3896,30 +3888,30 @@
 
 	fctx->attributes &= ~FCTX_ATTR_WANTCACHE;
 
-	LOCK(&fctx->res->buckets[fctx->bucketnum].lock);
+	__tm_atomic {
 
-	for (section = DNS_SECTION_ANSWER;
-	     section <= DNS_SECTION_ADDITIONAL;
-	     section++) {
-		result = dns_message_firstname(fctx->rmessage, section);
-		while (result == ISC_R_SUCCESS) {
-			name = NULL;
-			dns_message_currentname(fctx->rmessage, section,
-						&name);
-			if ((name->attributes & DNS_NAMEATTR_CACHE) != 0) {
-				result = cache_name(fctx, name, addrinfo, now);
-				if (result != ISC_R_SUCCESS)
-					break;
+		for (section = DNS_SECTION_ANSWER;
+		section <= DNS_SECTION_ADDITIONAL;
+		section++) {
+			result = dns_message_firstname(fctx->rmessage, section);
+			while (result == ISC_R_SUCCESS) {
+				name = NULL;
+				dns_message_currentname(fctx->rmessage, section,
+							&name);
+				if ((name->attributes & DNS_NAMEATTR_CACHE) != 0) {
+					result = cache_name(fctx, name, addrinfo, now);
+					if (result != ISC_R_SUCCESS)
+						break;
+				}
+				result = dns_message_nextname(fctx->rmessage, section);
 			}
-			result = dns_message_nextname(fctx->rmessage, section);
+			if (result != ISC_R_NOMORE)
+				break;
 		}
-		if (result != ISC_R_NOMORE)
-			break;
-	}
-	if (result == ISC_R_NOMORE)
-		result = ISC_R_SUCCESS;
+		if (result == ISC_R_NOMORE)
+			result = ISC_R_SUCCESS;
 
-	UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
+	}
 
 	return (result);
 }
@@ -4068,58 +4060,57 @@
 		return (result);
 	}
 
-	LOCK(&res->buckets[fctx->bucketnum].lock);
+	__tm_atomic {
 
-	adbp = NULL;
-	aname = NULL;
-	anodep = NULL;
-	ardataset = NULL;
-	if (!HAVE_ANSWER(fctx)) {
-		event = ISC_LIST_HEAD(fctx->events);
-		if (event != NULL) {
-			adbp = &event->db;
-			aname = dns_fixedname_name(&event->foundname);
-			result = dns_name_copy(name, aname, NULL);
-			if (result != ISC_R_SUCCESS)
-				goto unlock;
-			anodep = &event->node;
-			ardataset = event->rdataset;
-		}
-	} else
-		event = NULL;
-
-	result = dns_db_findnode(fctx->cache, name, ISC_TRUE, &node);
-	if (result != ISC_R_SUCCESS)
-		goto unlock;
-
-	/*
-	 * If we are asking for a SOA record set the cache time
-	 * to zero to facilitate locating the containing zone of
-	 * a arbitary zone.
-	 */
-	ttl = fctx->res->view->maxncachettl;
-	if (fctx->type == dns_rdatatype_soa &&
-	    covers == dns_rdatatype_any)
-		ttl = 0;
-
-	result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
-				   covers, now, ttl, ardataset, &eresult);
-	if (result != ISC_R_SUCCESS)
-		goto unlock;
-
-	if (!HAVE_ANSWER(fctx)) {
-		fctx->attributes |= FCTX_ATTR_HAVEANSWER;
-		if (event != NULL) {
-			event->result = eresult;
-			dns_db_attach(fctx->cache, adbp);
-			dns_db_transfernode(fctx->cache, &node, anodep);
-			clone_results(fctx);
+		adbp = NULL;
+		aname = NULL;
+		anodep = NULL;
+		ardataset = NULL;
+		if (!HAVE_ANSWER(fctx)) {
+			event = ISC_LIST_HEAD(fctx->events);
+			if (event != NULL) {
+				adbp = &event->db;
+				aname = dns_fixedname_name(&event->foundname);
+				result = dns_name_copy(name, aname, NULL);
+				if (result != ISC_R_SUCCESS)
+					goto unlock;
+				anodep = &event->node;
+				ardataset = event->rdataset;
+			}
+		} else
+			event = NULL;
+	
+		result = dns_db_findnode(fctx->cache, name, ISC_TRUE, &node);
+		if (result != ISC_R_SUCCESS)
+			goto unlock;
+	
+		/*
+		* If we are asking for a SOA record set the cache time
+		* to zero to facilitate locating the containing zone of
+		* a arbitary zone.
+		*/
+		ttl = fctx->res->view->maxncachettl;
+		if (fctx->type == dns_rdatatype_soa &&
+		covers == dns_rdatatype_any)
+			ttl = 0;
+	
+		result = ncache_adderesult(fctx->rmessage, fctx->cache, node,
+					covers, now, ttl, ardataset, &eresult);
+		if (result != ISC_R_SUCCESS)
+			goto unlock;
+	
+		if (!HAVE_ANSWER(fctx)) {
+			fctx->attributes |= FCTX_ATTR_HAVEANSWER;
+			if (event != NULL) {
+				event->result = eresult;
+				dns_db_attach(fctx->cache, adbp);
+				dns_db_transfernode(fctx->cache, &node, anodep);
+				clone_results(fctx);
+			}
 		}
+unlock:
 	}
 
- unlock:
-	UNLOCK(&res->buckets[fctx->bucketnum].lock);
-
 	if (node != NULL)
 		dns_db_detachnode(fctx->cache, &node);
 
@@ -5137,9 +5128,9 @@
 		if (result != ISC_R_SUCCESS)
 			fctx_done(fctx, result);
 		else {
-			LOCK(&res->buckets[bucketnum].lock);
-			locked = ISC_TRUE;
-			fctx->references++;
+			__tm_atomic {
+				fctx->references++;
+			}
 		}
 	}
 
@@ -5150,14 +5141,14 @@
 		dns_rdataset_disassociate(fevent->rdataset);
 	INSIST(fevent->sigrdataset == NULL);
 	isc_event_free(&event);
-	if (!locked)
-		LOCK(&res->buckets[bucketnum].lock);
-	fctx->references--;
-	if (fctx->references == 0)
-		bucket_empty = fctx_destroy(fctx);
-	UNLOCK(&res->buckets[bucketnum].lock);
-	if (bucket_empty)
-		empty_bucket(res);
+	
+	__tm_atomic {
+		fctx->references--;
+		if (fctx->references == 0)
+			bucket_empty = fctx_destroy(fctx);
+		if (bucket_empty)
+			empty_bucket(res);
+	}
 }
 
 static inline void
@@ -5822,9 +5813,9 @@
 						  &fctx->nsfetch);
 		if (result != ISC_R_SUCCESS)
 			fctx_done(fctx, result);
-		LOCK(&fctx->res->buckets[fctx->bucketnum].lock);
-		fctx->references++;
-		UNLOCK(&fctx->res->buckets[fctx->bucketnum].lock);
+		__tm_atomic {
+			fctx->references++;
+		}
 		result = fctx_stopidletimer(fctx);
 		if (result != ISC_R_SUCCESS)
 			fctx_done(fctx, result);
@@ -5861,7 +5852,6 @@
 		INSIST(ISC_LIST_EMPTY(res->buckets[i].fctxs));
 		isc_task_shutdown(res->buckets[i].task);
 		isc_task_detach(&res->buckets[i].task);
-		DESTROYLOCK(&res->buckets[i].lock);
 	}
 	isc_mem_put(res->mctx, res->buckets,
 		    res->nbuckets * sizeof(fctxbucket_t));
@@ -5974,13 +5964,9 @@
 		goto cleanup_res;
 	}
 	for (i = 0; i < ntasks; i++) {
-		result = isc_mutex_init(&res->buckets[i].lock);
-		if (result != ISC_R_SUCCESS)
-			goto cleanup_buckets;
 		res->buckets[i].task = NULL;
 		result = isc_task_create(taskmgr, 0, &res->buckets[i].task);
 		if (result != ISC_R_SUCCESS) {
-			DESTROYLOCK(&res->buckets[i].lock);
 			goto cleanup_buckets;
 		}
 		snprintf(name, sizeof(name), "res%u", i);
@@ -6059,7 +6045,6 @@
 
  cleanup_buckets:
 	for (i = 0; i < buckets_created; i++) {
-		DESTROYLOCK(&res->buckets[i].lock);
 		isc_task_shutdown(res->buckets[i].task);
 		isc_task_detach(&res->buckets[i].task);
 	}
@@ -6248,27 +6233,27 @@
 		res->exiting = ISC_TRUE;
 
 		for (i = 0; i < res->nbuckets; i++) {
-			LOCK(&res->buckets[i].lock);
-			for (fctx = ISC_LIST_HEAD(res->buckets[i].fctxs);
-			     fctx != NULL;
-			     fctx = ISC_LIST_NEXT(fctx, link))
-				fctx_shutdown(fctx);
-			if (res->dispatchv4 != NULL) {
-				sock = dns_dispatch_getsocket(res->dispatchv4);
-				isc_socket_cancel(sock, res->buckets[i].task,
-						  ISC_SOCKCANCEL_ALL);
-			}
-			if (res->dispatchv6 != NULL) {
-				sock = dns_dispatch_getsocket(res->dispatchv6);
-				isc_socket_cancel(sock, res->buckets[i].task,
-						  ISC_SOCKCANCEL_ALL);
-			}
-			res->buckets[i].exiting = ISC_TRUE;
-			if (ISC_LIST_EMPTY(res->buckets[i].fctxs)) {
-				INSIST(res->activebuckets > 0);
-				res->activebuckets--;
+			__tm_atomic {
+				for (fctx = ISC_LIST_HEAD(res->buckets[i].fctxs);
+				fctx != NULL;
+				fctx = ISC_LIST_NEXT(fctx, link))
+					fctx_shutdown(fctx);
+				if (res->dispatchv4 != NULL) {
+					sock = dns_dispatch_getsocket(res->dispatchv4);
+					isc_socket_cancel(sock, res->buckets[i].task,
+							ISC_SOCKCANCEL_ALL);
+				}
+				if (res->dispatchv6 != NULL) {
+					sock = dns_dispatch_getsocket(res->dispatchv6);
+					isc_socket_cancel(sock, res->buckets[i].task,
+							ISC_SOCKCANCEL_ALL);
+				}
+				res->buckets[i].exiting = ISC_TRUE;
+				if (ISC_LIST_EMPTY(res->buckets[i].fctxs)) {
+					INSIST(res->activebuckets > 0);
+					res->activebuckets--;
+				}
 			}
-			UNLOCK(&res->buckets[i].lock);
 		}
 		if (res->activebuckets == 0)
 			send_shutdown_events(res);
@@ -6376,65 +6361,63 @@
 
 	bucketnum = dns_name_hash(name, ISC_FALSE) % res->nbuckets;
 
-	LOCK(&res->buckets[bucketnum].lock);
-
-	if (res->buckets[bucketnum].exiting) {
-		result = ISC_R_SHUTTINGDOWN;
-		goto unlock;
-	}
-
-	if ((options & DNS_FETCHOPT_UNSHARED) == 0) {
-		for (fctx = ISC_LIST_HEAD(res->buckets[bucketnum].fctxs);
-		     fctx != NULL;
-		     fctx = ISC_LIST_NEXT(fctx, link)) {
-			if (fctx_match(fctx, name, type, options))
-				break;
+	__tm_atomic {
+	
+		if (res->buckets[bucketnum].exiting) {
+			result = ISC_R_SHUTTINGDOWN;
 		}
-	}
-
-	/*
-	 * If we didn't have a fetch, would attach to a done fetch, this
-	 * fetch has already cloned its results, or if the fetch has gone
-	 * "idle" (no one was interested in it), we need to start a new
-	 * fetch instead of joining with the existing one.
-	 */
-	if (fctx == NULL ||
-	    fctx->state == fetchstate_done ||
-	    fctx->cloned ||
-	    ISC_LIST_EMPTY(fctx->events)) {
-		fctx = NULL;
-		result = fctx_create(res, name, type, domain, nameservers,
-				     options, bucketnum, &fctx);
-		if (result != ISC_R_SUCCESS)
-			goto unlock;
-		new_fctx = ISC_TRUE;
-	}
-
-	result = fctx_join(fctx, task, action, arg,
-			   rdataset, sigrdataset, fetch);
-	if (new_fctx) {
-		if (result == ISC_R_SUCCESS) {
-			/*
-			 * Launch this fctx.
-			 */
-			event = &fctx->control_event;
-			ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
-				       DNS_EVENT_FETCHCONTROL,
-				       fctx_start, fctx, NULL,
-				       NULL, NULL);
-			isc_task_send(res->buckets[bucketnum].task, &event);
-		} else {
+		else {
+			if ((options & DNS_FETCHOPT_UNSHARED) == 0) {
+				for (fctx = ISC_LIST_HEAD(res->buckets[bucketnum].fctxs);
+				fctx != NULL;
+				fctx = ISC_LIST_NEXT(fctx, link)) {
+					if (fctx_match(fctx, name, type, options))
+						break;
+				}
+			}
+		
 			/*
-			 * We don't care about the result of fctx_destroy()
-			 * since we know we're not exiting.
-			 */
-			(void)fctx_destroy(fctx);
+			* If we didn't have a fetch, would attach to a done fetch, this
+			* fetch has already cloned its results, or if the fetch has gone
+			* "idle" (no one was interested in it), we need to start a new
+			* fetch instead of joining with the existing one.
+			*/
+			if (fctx == NULL ||
+			fctx->state == fetchstate_done ||
+			fctx->cloned ||
+			ISC_LIST_EMPTY(fctx->events)) {
+				fctx = NULL;
+				result = fctx_create(res, name, type, domain, nameservers,
+						options, bucketnum, &fctx);
+				if (result == ISC_R_SUCCESS) {
+					new_fctx = ISC_TRUE;
+				}
+			}
+		
+			result = fctx_join(fctx, task, action, arg,
+					rdataset, sigrdataset, fetch);
+			if (new_fctx) {
+				if (result == ISC_R_SUCCESS) {
+					/*
+					* Launch this fctx.
+					*/
+					event = &fctx->control_event;
+					ISC_EVENT_INIT(event, sizeof(*event), 0, NULL,
+						DNS_EVENT_FETCHCONTROL,
+						fctx_start, fctx, NULL,
+						NULL, NULL);
+					isc_task_send(res->buckets[bucketnum].task, &event);
+				} else {
+					/*
+					* We don't care about the result of fctx_destroy()
+					* since we know we're not exiting.
+					*/
+					(void)fctx_destroy(fctx);
+				}
+			}
 		}
 	}
 
- unlock:
-	UNLOCK(&res->buckets[bucketnum].lock);
-
 	if (result == ISC_R_SUCCESS) {
 		FTRACE("created");
 		*fetchp = fetch;
@@ -6458,37 +6441,37 @@
 
 	FTRACE("cancelfetch");
 
-	LOCK(&res->buckets[fctx->bucketnum].lock);
+	__tm_atomic {
 
-	/*
-	 * Find the completion event for this fetch (as opposed
-	 * to those for other fetches that have joined the same
-	 * fctx) and send it with result = ISC_R_CANCELED.
-	 */
-	event = NULL;
-	if (fctx->state != fetchstate_done) {
-		for (event = ISC_LIST_HEAD(fctx->events);
-		     event != NULL;
-		     event = next_event) {
-			next_event = ISC_LIST_NEXT(event, ev_link);
-			if (event->fetch == fetch) {
-				ISC_LIST_UNLINK(fctx->events, event, ev_link);
-				break;
+		/*
+		* Find the completion event for this fetch (as opposed
+		* to those for other fetches that have joined the same
+		* fctx) and send it with result = ISC_R_CANCELED.
+		*/
+		event = NULL;
+		if (fctx->state != fetchstate_done) {
+			for (event = ISC_LIST_HEAD(fctx->events);
+			event != NULL;
+			event = next_event) {
+				next_event = ISC_LIST_NEXT(event, ev_link);
+				if (event->fetch == fetch) {
+					ISC_LIST_UNLINK(fctx->events, event, ev_link);
+					break;
+				}
 			}
 		}
-	}
-	if (event != NULL) {
-		etask = event->ev_sender;
-		event->ev_sender = fctx;
-		event->result = ISC_R_CANCELED;
-		isc_task_sendanddetach(&etask, ISC_EVENT_PTR(&event));
-	}
-	/*
-	 * The fctx continues running even if no fetches remain;
-	 * the answer is still cached.
-	 */
+		if (event != NULL) {
+			etask = event->ev_sender;
+			event->ev_sender = fctx;
+			event->result = ISC_R_CANCELED;
+			isc_task_sendanddetach(&etask, ISC_EVENT_PTR(&event));
+		}
+		/*
+		* The fctx continues running even if no fetches remain;
+		* the answer is still cached.
+		*/
 
-	UNLOCK(&res->buckets[fctx->bucketnum].lock);
+	}
 }
 
 void
@@ -6510,45 +6493,45 @@
 	FTRACE("destroyfetch");
 
 	bucketnum = fctx->bucketnum;
-	LOCK(&res->buckets[bucketnum].lock);
-
-	/*
-	 * Sanity check: the caller should have gotten its event before
-	 * trying to destroy the fetch.
-	 */
-	event = NULL;
-	if (fctx->state != fetchstate_done) {
-		for (event = ISC_LIST_HEAD(fctx->events);
-		     event != NULL;
-		     event = next_event) {
-			next_event = ISC_LIST_NEXT(event, ev_link);
-			RUNTIME_CHECK(event->fetch != fetch);
-		}
-	}
-
-	INSIST(fctx->references > 0);
-	fctx->references--;
-	if (fctx->references == 0) {
+	
+	__tm_atomic {
 		/*
-		 * No one cares about the result of this fetch anymore.
-		 */
-		if (fctx->pending == 0 && fctx->nqueries == 0 &&
-		    ISC_LIST_EMPTY(fctx->validators) &&
-		    SHUTTINGDOWN(fctx)) {
-			/*
-			 * This fctx is already shutdown; we were just
-			 * waiting for the last reference to go away.
-			 */
-			bucket_empty = fctx_destroy(fctx);
-		} else {
+		* Sanity check: the caller should have gotten its event before
+		* trying to destroy the fetch.
+		*/
+		event = NULL;
+		if (fctx->state != fetchstate_done) {
+			for (event = ISC_LIST_HEAD(fctx->events);
+			event != NULL;
+			event = next_event) {
+				next_event = ISC_LIST_NEXT(event, ev_link);
+				RUNTIME_CHECK(event->fetch != fetch);
+			}
+		}
+	
+		INSIST(fctx->references > 0);
+		fctx->references--;
+		if (fctx->references == 0) {
 			/*
-			 * Initiate shutdown.
-			 */
-			fctx_shutdown(fctx);
+			* No one cares about the result of this fetch anymore.
+			*/
+			if (fctx->pending == 0 && fctx->nqueries == 0 &&
+			ISC_LIST_EMPTY(fctx->validators) &&
+			SHUTTINGDOWN(fctx)) {
+				/*
+				* This fctx is already shutdown; we were just
+				* waiting for the last reference to go away.
+				*/
+				bucket_empty = fctx_destroy(fctx);
+			} else {
+				/*
+				* Initiate shutdown.
+				*/
+				fctx_shutdown(fctx);
+			}
 		}
-	}
 
-	UNLOCK(&res->buckets[bucketnum].lock);
+	}
 
 	isc_mem_put(res->mctx, fetch, sizeof(*fetch));
 	*fetchp = NULL;
diff -Naur -x Makefile -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/mem.c bind-modified/lib/isc/mem.c
--- bind-9.3.5-P2/lib/isc/mem.c	2007-11-26 17:45:51.000000000 -0600
+++ bind-modified/lib/isc/mem.c	2008-10-08 02:11:37.000000000 -0500
@@ -115,7 +115,6 @@
 struct isc_mem {
 	unsigned int		magic;
 	isc_ondestroy_t		ondestroy;
-	isc_mutex_t		lock;
 	isc_memalloc_t		memalloc;
 	isc_memfree_t		memfree;
 	void *			arg;
@@ -158,7 +157,6 @@
 struct isc_mempool {
 	/* always unlocked */
 	unsigned int	magic;		/* magic number */
-	isc_mutex_t    *lock;		/* optional lock */
 	isc_mem_t      *mctx;		/* our memory context */
 	/* locked via the memory context's lock */
 	ISC_LINK(isc_mempool_t)	link;	/* next pool in this mem context */
@@ -717,15 +715,6 @@
 	if (ctx == NULL)
 		return (ISC_R_NOMEMORY);
 
-	if (isc_mutex_init(&ctx->lock) != ISC_R_SUCCESS) {
-		UNEXPECTED_ERROR(__FILE__, __LINE__,
-				 "isc_mutex_init() %s",
-				 isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,
-						ISC_MSG_FAILED, "failed"));
-		(memfree)(arg, ctx);
-		return (ISC_R_UNEXPECTED);
-	}
-
 	if (init_max_size == 0U)
 		ctx->max_size = DEF_MAX_SIZE;
 	else
@@ -816,7 +805,6 @@
 		if (ctx->debuglist != NULL)
 			(ctx->memfree)(ctx->arg, ctx->debuglist);
 #endif /* ISC_MEM_TRACKLINES */
-		DESTROYLOCK(&ctx->lock);
 		(memfree)(arg, ctx);
 	}
 
@@ -890,7 +878,6 @@
 
 	ondest = ctx->ondestroy;
 
-	DESTROYLOCK(&ctx->lock);
 	(ctx->memfree)(ctx->arg, ctx);
 
 	isc_ondestroy_notify(&ondest, ctx);
@@ -901,9 +888,9 @@
 	REQUIRE(VALID_CONTEXT(source));
 	REQUIRE(targetp != NULL && *targetp == NULL);
 
-	LOCK(&source->lock);
-	source->references++;
-	UNLOCK(&source->lock);
+	__tm_atomic {
+		source->references++;
+	}
 
 	*targetp = source;
 }
@@ -917,12 +904,12 @@
 	ctx = *ctxp;
 	REQUIRE(VALID_CONTEXT(ctx));
 
-	LOCK(&ctx->lock);
-	INSIST(ctx->references > 0);
-	ctx->references--;
-	if (ctx->references == 0)
-		want_destroy = ISC_TRUE;
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		INSIST(ctx->references > 0);
+		ctx->references--;
+		if (ctx->references == 0)
+			want_destroy = ISC_TRUE;
+	}
 
 	if (want_destroy)
 		destroy(ctx);
@@ -956,22 +943,20 @@
 	 */
 	*ctxp = NULL;
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, ptr, size);
+		mem_putunlocked(ctx, ptr, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	mem_put(ctx, ptr, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, ptr, size);
+		mem_put(ctx, ptr, size);
+		mem_putstats(ctx, ptr, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
-	INSIST(ctx->references > 0);
-	ctx->references--;
-	if (ctx->references == 0)
-		want_destroy = ISC_TRUE;
-
-	UNLOCK(&ctx->lock);
+		DELETE_TRACE(ctx, ptr, size, file, line);
+		INSIST(ctx->references > 0);
+		ctx->references--;
+		if (ctx->references == 0)
+			want_destroy = ISC_TRUE;
+	}
 
 	if (want_destroy)
 		destroy(ctx);
@@ -990,14 +975,14 @@
 	ctx = *ctxp;
 	REQUIRE(VALID_CONTEXT(ctx));
 
-	LOCK(&ctx->lock);
+	__tm_atomic {
 #if ISC_MEM_TRACKLINES
-	if (ctx->references != 1)
-		print_active(ctx, stderr);
+		if (ctx->references != 1)
+			print_active(ctx, stderr);
 #endif
-	REQUIRE(ctx->references == 1);
-	ctx->references--;
-	UNLOCK(&ctx->lock);
+		REQUIRE(ctx->references == 1);
+		ctx->references--;
+	}
 
 	destroy(ctx);
 
@@ -1008,9 +993,9 @@
 isc_mem_ondestroy(isc_mem_t *ctx, isc_task_t *task, isc_event_t **event) {
 	isc_result_t res;
 
-	LOCK(&ctx->lock);
-	res = isc_ondestroy_register(&ctx->ondestroy, task, event);
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		res = isc_ondestroy_register(&ctx->ondestroy, task, event);
+	}
 
 	return (res);
 }
@@ -1023,30 +1008,29 @@
 
 	REQUIRE(VALID_CONTEXT(ctx));
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	ptr = mem_getunlocked(ctx, size);
+		ptr = mem_getunlocked(ctx, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	ptr = mem_get(ctx, size);
-	LOCK(&ctx->lock);
-	if (ptr != NULL)
-		mem_getstats(ctx, size);
+		ptr = mem_get(ctx, size);
+		if (ptr != NULL)
+			mem_getstats(ctx, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	ADD_TRACE(ctx, ptr, size, file, line);
-	if (ctx->hi_water != 0U && !ctx->hi_called &&
-	    ctx->inuse > ctx->hi_water) {
-		ctx->hi_called = ISC_TRUE;
-		call_water = ISC_TRUE;
-	}
-	if (ctx->inuse > ctx->maxinuse) {
-		ctx->maxinuse = ctx->inuse;
-		if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
-		    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
-			fprintf(stderr, "maxinuse = %lu\n",
-				(unsigned long)ctx->inuse);
+		ADD_TRACE(ctx, ptr, size, file, line);
+		if (ctx->hi_water != 0U && !ctx->hi_called &&
+		    ctx->inuse > ctx->hi_water) {
+			ctx->hi_called = ISC_TRUE;
+			call_water = ISC_TRUE;
+		}
+		if (ctx->inuse > ctx->maxinuse) {
+			ctx->maxinuse = ctx->inuse;
+			if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
+			    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
+				fprintf(stderr, "maxinuse = %lu\n",
+					(unsigned long)ctx->inuse);
+		}
 	}
-	UNLOCK(&ctx->lock);
 
 	if (call_water)
 		(ctx->water)(ctx->water_arg, ISC_MEM_HIWATER);
@@ -1062,30 +1046,29 @@
 	REQUIRE(VALID_CONTEXT(ctx));
 	REQUIRE(ptr != NULL);
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, ptr, size);
+		mem_putunlocked(ctx, ptr, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	mem_put(ctx, ptr, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, ptr, size);
+		mem_put(ctx, ptr, size);
+		mem_putstats(ctx, ptr, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
+		DELETE_TRACE(ctx, ptr, size, file, line);
 
-	/*
-	 * The check against ctx->lo_water == 0 is for the condition
-	 * when the context was pushed over hi_water but then had
-	 * isc_mem_setwater() called with 0 for hi_water and lo_water.
-	 */
-	if (ctx->hi_called && 
-	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
-		ctx->hi_called = ISC_FALSE;
+		/*
+		 * The check against ctx->lo_water == 0 is for the condition
+		 * when the context was pushed over hi_water but then had
+		 * isc_mem_setwater() called with 0 for hi_water and lo_water.
+		 */
+		if (ctx->hi_called && 
+		    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
+			ctx->hi_called = ISC_FALSE;
 
-		if (ctx->water != NULL)
-			call_water = ISC_TRUE;
+			if (ctx->water != NULL)
+				call_water = ISC_TRUE;
+		}
 	}
-	UNLOCK(&ctx->lock);
 
 	if (call_water)
 		(ctx->water)(ctx->water_arg, ISC_MEM_LOWATER);
@@ -1142,69 +1125,69 @@
 	const isc_mempool_t *pool;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
+	__tm_atomic {
 
-	for (i = 0; i <= ctx->max_size; i++) {
-		s = &ctx->stats[i];
+		for (i = 0; i <= ctx->max_size; i++) {
+			s = &ctx->stats[i];
 
-		if (s->totalgets == 0U && s->gets == 0U)
-			continue;
-		fprintf(out, "%s%5lu: %11lu gets, %11lu rem",
-			(i == ctx->max_size) ? ">=" : "  ",
-			(unsigned long) i, s->totalgets, s->gets);
+			if (s->totalgets == 0U && s->gets == 0U)
+				continue;
+			fprintf(out, "%s%5lu: %11lu gets, %11lu rem",
+				(i == ctx->max_size) ? ">=" : "  ",
+				(unsigned long) i, s->totalgets, s->gets);
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		if (s->blocks != 0 || s->freefrags != 0)
-			fprintf(out, " (%lu bl, %lu ff)",
-				s->blocks, s->freefrags);
+			if (s->blocks != 0 || s->freefrags != 0)
+				fprintf(out, " (%lu bl, %lu ff)",
+					s->blocks, s->freefrags);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		fputc('\n', out);
-	}
+			fputc('\n', out);
+		}
 
-	/*
-	 * Note that since a pool can be locked now, these stats might be
-	 * somewhat off if the pool is in active use at the time the stats
-	 * are dumped.  The link fields are protected by the isc_mem_t's
-	 * lock, however, so walking this list and extracting integers from
-	 * stats fields is always safe.
-	 */
-	pool = ISC_LIST_HEAD(ctx->pools);
-	if (pool != NULL) {
-		fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-					    ISC_MSG_POOLSTATS,
-					    "[Pool statistics]\n"));
-		fprintf(out, "%15s %10s %10s %10s %10s %10s %10s %10s %1s\n",
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLNAME, "name"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLSIZE, "size"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLMAXALLOC, "maxalloc"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLALLOCATED, "allocated"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFREECOUNT, "freecount"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFREEMAX, "freemax"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLFILLCOUNT, "fillcount"),
-			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
-				       ISC_MSG_POOLGETS, "gets"),
-			"L");
-	}
-	while (pool != NULL) {
-		fprintf(out, "%15s %10lu %10u %10u %10u %10u %10u %10u %s\n",
-			pool->name, (unsigned long) pool->size, pool->maxalloc,
-			pool->allocated, pool->freecount, pool->freemax,
-			pool->fillcount, pool->gets,
-			(pool->lock == NULL ? "N" : "Y"));
-		pool = ISC_LIST_NEXT(pool, link);
-	}
+		/*
+		 * Note that since a pool can be locked now, these stats might be
+		 * somewhat off if the pool is in active use at the time the stats
+		 * are dumped.  The link fields are protected by the isc_mem_t's
+		 * lock, however, so walking this list and extracting integers from
+		 * stats fields is always safe.
+		 */
+		pool = ISC_LIST_HEAD(ctx->pools);
+		if (pool != NULL) {
+			fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+						    ISC_MSG_POOLSTATS,
+						    "[Pool statistics]\n"));
+			fprintf(out, "%15s %10s %10s %10s %10s %10s %10s %10s %1s\n",
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLNAME, "name"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLSIZE, "size"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLMAXALLOC, "maxalloc"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLALLOCATED, "allocated"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFREECOUNT, "freecount"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFREEMAX, "freemax"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLFILLCOUNT, "fillcount"),
+				isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
+					       ISC_MSG_POOLGETS, "gets"),
+				"L");
+		}
+		while (pool != NULL) {
+			fprintf(out, "%15s %10lu %10u %10u %10u %10u %10u %10u %s\n",
+				pool->name, (unsigned long) pool->size, pool->maxalloc,
+				pool->allocated, pool->freecount, pool->freemax,
+				pool->fillcount, pool->gets,
+				"Y");
+			pool = ISC_LIST_NEXT(pool, link);
+		}
 
 #if ISC_MEM_TRACKLINES
-	print_active(ctx, out);
+		print_active(ctx, out);
 #endif
 
-	UNLOCK(&ctx->lock);
+	}
 }
 
 /*
@@ -1234,21 +1217,19 @@
 
 	REQUIRE(VALID_CONTEXT(ctx));
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	si = isc__mem_allocateunlocked(ctx, size);
+		si = isc__mem_allocateunlocked(ctx, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	si = isc__mem_allocateunlocked(ctx, size);
-	LOCK(&ctx->lock);
-	if (si != NULL)
-		mem_getstats(ctx, si[-1].u.size);
+		si = isc__mem_allocateunlocked(ctx, size);
+		if (si != NULL)
+			mem_getstats(ctx, si[-1].u.size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
 
 #if ISC_MEM_TRACKLINES
-	ADD_TRACE(ctx, si, si[-1].u.size, file, line);
+		ADD_TRACE(ctx, si, si[-1].u.size, file, line);
 #endif
-
-	UNLOCK(&ctx->lock);
+	}
 
 	return (si);
 }
@@ -1264,18 +1245,16 @@
 	si = &(((size_info *)ptr)[-1]);
 	size = si->u.size;
 
+	__tm_atomic {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-	LOCK(&ctx->lock);
-	mem_putunlocked(ctx, si, size);
+		mem_putunlocked(ctx, si, size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-	mem_put(ctx, si, size);
-	LOCK(&ctx->lock);
-	mem_putstats(ctx, si, size);
+		mem_put(ctx, si, size);
+		mem_putstats(ctx, si, size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
+		DELETE_TRACE(ctx, ptr, size, file, line);
 
-	DELETE_TRACE(ctx, ptr, size, file, line);
-
-	UNLOCK(&ctx->lock);
+	}
 }
 
 
@@ -1304,11 +1283,9 @@
 void
 isc_mem_setdestroycheck(isc_mem_t *ctx, isc_boolean_t flag) {
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	ctx->checkfree = flag;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		ctx->checkfree = flag;
+	}
 }
 
 /*
@@ -1318,11 +1295,9 @@
 void
 isc_mem_setquota(isc_mem_t *ctx, size_t quota) {
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	ctx->quota = quota;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		ctx->quota = quota;
+	}
 }
 
 size_t
@@ -1330,11 +1305,9 @@
 	size_t quota;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	quota = ctx->quota;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		quota = ctx->quota;
+	}
 
 	return (quota);
 }
@@ -1344,11 +1317,9 @@
 	size_t inuse;
 
 	REQUIRE(VALID_CONTEXT(ctx));
-	LOCK(&ctx->lock);
-
-	inuse = ctx->inuse;
-
-	UNLOCK(&ctx->lock);
+	__tm_atomic {
+		inuse = ctx->inuse;
+	}
 
 	return (inuse);
 }
@@ -1364,28 +1335,28 @@
 	REQUIRE(VALID_CONTEXT(ctx));
 	REQUIRE(hiwater >= lowater);
 
-	LOCK(&ctx->lock);
-	oldwater = ctx->water;
-	oldwater_arg = ctx->water_arg;
-	if (water == NULL) {
-		callwater = ctx->hi_called;
-		ctx->water = NULL;
-		ctx->water_arg = NULL;
-		ctx->hi_water = 0;
-		ctx->lo_water = 0;
-		ctx->hi_called = ISC_FALSE;
-	} else {
-		if (ctx->hi_called &&
-		    (ctx->water != water || ctx->water_arg != water_arg ||
-		     ctx->inuse < lowater || lowater == 0U))
-			callwater = ISC_TRUE;
-		ctx->water = water;
-		ctx->water_arg = water_arg;
-		ctx->hi_water = hiwater;
-		ctx->lo_water = lowater;
-		ctx->hi_called = ISC_FALSE;
+	__tm_atomic {
+		oldwater = ctx->water;
+		oldwater_arg = ctx->water_arg;
+		if (water == NULL) {
+			callwater = ctx->hi_called;
+			ctx->water = NULL;
+			ctx->water_arg = NULL;
+			ctx->hi_water = 0;
+			ctx->lo_water = 0;
+			ctx->hi_called = ISC_FALSE;
+		} else {
+			if (ctx->hi_called &&
+			    (ctx->water != water || ctx->water_arg != water_arg ||
+			     ctx->inuse < lowater || lowater == 0U))
+				callwater = ISC_TRUE;
+			ctx->water = water;
+			ctx->water_arg = water_arg;
+			ctx->hi_water = hiwater;
+			ctx->lo_water = lowater;
+			ctx->hi_called = ISC_FALSE;
+		}
 	}
-	UNLOCK(&ctx->lock);
 
 	if (callwater && oldwater != NULL)
 		(oldwater)(oldwater_arg, ISC_MEM_LOWATER);
@@ -1412,7 +1383,6 @@
 		return (ISC_R_NOMEMORY);
 
 	mpctx->magic = MEMPOOL_MAGIC;
-	mpctx->lock = NULL;
 	mpctx->mctx = mctx;
 	mpctx->size = size;
 	mpctx->maxalloc = UINT_MAX;
@@ -1428,9 +1398,9 @@
 
 	*mpctxp = mpctx;
 
-	LOCK(&mctx->lock);
-	ISC_LIST_INITANDAPPEND(mctx->pools, mpctx, link);
-	UNLOCK(&mctx->lock);
+	__tm_atomic {
+		ISC_LIST_INITANDAPPEND(mctx->pools, mpctx, link);
+	}
 
 	return (ISC_R_SUCCESS);
 }
@@ -1440,14 +1410,10 @@
 	REQUIRE(name != NULL);
 
 #if ISC_MEMPOOL_NAMES
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	strncpy(mpctx->name, name, sizeof(mpctx->name) - 1);
-	mpctx->name[sizeof(mpctx->name) - 1] = '\0';
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		strncpy(mpctx->name, name, sizeof(mpctx->name) - 1);
+		mpctx->name[sizeof(mpctx->name) - 1] = '\0';
+	}
 #else
 	UNUSED(mpctx);
 	UNUSED(name);
@@ -1458,7 +1424,6 @@
 isc_mempool_destroy(isc_mempool_t **mpctxp) {
 	isc_mempool_t *mpctx;
 	isc_mem_t *mctx;
-	isc_mutex_t *lock;
 	element *item;
 
 	REQUIRE(mpctxp != NULL);
@@ -1475,43 +1440,38 @@
 
 	mctx = mpctx->mctx;
 
-	lock = mpctx->lock;
+	__tm_atomic {
 
-	if (lock != NULL)
-		LOCK(lock);
-
-	/*
-	 * Return any items on the free list
-	 */
-	LOCK(&mctx->lock);
-	while (mpctx->items != NULL) {
-		INSIST(mpctx->freecount > 0);
-		mpctx->freecount--;
-		item = mpctx->items;
-		mpctx->items = item->next;
+		/*
+		 * Return any items on the free list
+		 */
+		__tm_atomic {
+			while (mpctx->items != NULL) {
+				INSIST(mpctx->freecount > 0);
+				mpctx->freecount--;
+				item = mpctx->items;
+				mpctx->items = item->next;
 
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		mem_putunlocked(mctx, item, mpctx->size);
+				mem_putunlocked(mctx, item, mpctx->size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		mem_put(mctx, item, mpctx->size);
-		mem_putstats(mctx, item, mpctx->size);
+				mem_put(mctx, item, mpctx->size);
+				mem_putstats(mctx, item, mpctx->size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-	}
-	UNLOCK(&mctx->lock);
-
-	/*
-	 * Remove our linked list entry from the memory context.
-	 */
-	LOCK(&mctx->lock);
-	ISC_LIST_UNLINK(mctx->pools, mpctx, link);
-	UNLOCK(&mctx->lock);
+			}
+		}
 
-	mpctx->magic = 0;
+		/*
+		 * Remove our linked list entry from the memory context.
+		 */
+		__tm_atomic {
+			ISC_LIST_UNLINK(mctx->pools, mpctx, link);
+		}
 
-	isc_mem_put(mpctx->mctx, mpctx, sizeof(isc_mempool_t));
+		mpctx->magic = 0;
 
-	if (lock != NULL)
-		UNLOCK(lock);
+		isc_mem_put(mpctx->mctx, mpctx, sizeof(isc_mempool_t));
+	}
 
 	*mpctxp = NULL;
 }
@@ -1519,10 +1479,10 @@
 void
 isc_mempool_associatelock(isc_mempool_t *mpctx, isc_mutex_t *lock) {
 	REQUIRE(VALID_MEMPOOL(mpctx));
-	REQUIRE(mpctx->lock == NULL);
+	// REQUIRE(mpctx->lock == NULL);
 	REQUIRE(lock != NULL);
 
-	mpctx->lock = lock;
+	// mpctx->lock = lock;
 }
 
 void *
@@ -1535,72 +1495,70 @@
 
 	mctx = mpctx->mctx;
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	/*
-	 * Don't let the caller go over quota
-	 */
-	if (mpctx->allocated >= mpctx->maxalloc) {
-		item = NULL;
-		goto out;
-	}
+	__tm_atomic {
 
-	/*
-	 * if we have a free list item, return the first here
-	 */
-	item = mpctx->items;
-	if (item != NULL) {
-		mpctx->items = item->next;
-		INSIST(mpctx->freecount > 0);
-		mpctx->freecount--;
-		mpctx->gets++;
-		mpctx->allocated++;
-		goto out;
-	}
-
-	/*
-	 * We need to dip into the well.  Lock the memory context here and
-	 * fill up our free list.
-	 */
-	LOCK(&mctx->lock);
-	for (i = 0; i < mpctx->fillcount; i++) {
+		/*
+		 * Don't let the caller go over quota
+		 */
+		if (mpctx->allocated >= mpctx->maxalloc) {
+			item = NULL;
+		}
+		else
+		{
+			/*
+			 * if we have a free list item, return the first here
+			 */
+			item = mpctx->items;
+			if (item != NULL) {
+				mpctx->items = item->next;
+				INSIST(mpctx->freecount > 0);
+				mpctx->freecount--;
+				mpctx->gets++;
+				mpctx->allocated++;
+			}
+			else
+			{
+				/*
+				 * We need to dip into the well.  Lock the memory context here and
+				 * fill up our free list.
+				 */
+				__tm_atomic {
+					for (i = 0; i < mpctx->fillcount; i++) {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		item = mem_getunlocked(mctx, mpctx->size);
+						item = mem_getunlocked(mctx, mpctx->size);
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		item = mem_get(mctx, mpctx->size);
-		if (item != NULL)
-			mem_getstats(mctx, mpctx->size);
+						item = mem_get(mctx, mpctx->size);
+						if (item != NULL)
+							mem_getstats(mctx, mpctx->size);
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		if (item == NULL)
-			break;
-		item->next = mpctx->items;
-		mpctx->items = item;
-		mpctx->freecount++;
-	}
-	UNLOCK(&mctx->lock);
+						if (item == NULL)
+							break;
+						item->next = mpctx->items;
+						mpctx->items = item;
+						mpctx->freecount++;
+					}
+				}
 
-	/*
-	 * If we didn't get any items, return NULL.
-	 */
-	item = mpctx->items;
-	if (item == NULL)
-		goto out;
-
-	mpctx->items = item->next;
-	mpctx->freecount--;
-	mpctx->gets++;
-	mpctx->allocated++;
-
- out:
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+				/*
+				 * If we didn't get any items, return NULL.
+				 */
+				item = mpctx->items;
+				if (item != NULL)
+				{
+					mpctx->items = item->next;
+					mpctx->freecount--;
+					mpctx->gets++;
+					mpctx->allocated++;
+				}
+			}
+		}
+	}
 
 #if ISC_MEM_TRACKLINES
 	if (item != NULL) {
-		LOCK(&mctx->lock);
-		ADD_TRACE(mctx, item, mpctx->size, file, line);
-		UNLOCK(&mctx->lock);
+		__tm_atomic {
+			ADD_TRACE(mctx, item, mpctx->size, file, line);
+		}
 	}
 #endif /* ISC_MEM_TRACKLINES */
 
@@ -1617,47 +1575,41 @@
 
 	mctx = mpctx->mctx;
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	INSIST(mpctx->allocated > 0);
-	mpctx->allocated--;
+	__tm_atomic {
+		INSIST(mpctx->allocated > 0);
+		mpctx->allocated--;
 
 #if ISC_MEM_TRACKLINES
-	LOCK(&mctx->lock);
-	DELETE_TRACE(mctx, mem, mpctx->size, file, line);
-	UNLOCK(&mctx->lock);
+		__tm_atomic {
+			DELETE_TRACE(mctx, mem, mpctx->size, file, line);
+		}
 #endif /* ISC_MEM_TRACKLINES */
 
-	/*
-	 * If our free list is full, return this to the mctx directly.
-	 */
-	if (mpctx->freecount >= mpctx->freemax) {
+		/*
+		 * If our free list is full, return this to the mctx directly.
+		 */
+		if (mpctx->freecount >= mpctx->freemax) {
 #if ISC_MEM_USE_INTERNAL_MALLOC
-		LOCK(&mctx->lock);
-		mem_putunlocked(mctx, mem, mpctx->size);
-		UNLOCK(&mctx->lock);
+			__tm_atomic {
+				mem_putunlocked(mctx, mem, mpctx->size);
+			}
 #else /* ISC_MEM_USE_INTERNAL_MALLOC */
-		mem_put(mctx, mem, mpctx->size);
-		LOCK(&mctx->lock);
-		mem_putstats(mctx, mem, mpctx->size);
-		UNLOCK(&mctx->lock);
+			mem_put(mctx, mem, mpctx->size);
+			__tm_atomic {
+				mem_putstats(mctx, mem, mpctx->size);
+			}
 #endif /* ISC_MEM_USE_INTERNAL_MALLOC */
-		if (mpctx->lock != NULL)
-			UNLOCK(mpctx->lock);
-		return;
+		}
+		else {
+			/*
+			 * Otherwise, attach it to our free list and bump the counter.
+			 */
+			mpctx->freecount++;
+			item = (element *)mem;
+			item->next = mpctx->items;
+			mpctx->items = item;
+		}
 	}
-
-	/*
-	 * Otherwise, attach it to our free list and bump the counter.
-	 */
-	mpctx->freecount++;
-	item = (element *)mem;
-	item->next = mpctx->items;
-	mpctx->items = item;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
 }
 
 /*
@@ -1668,13 +1620,9 @@
 isc_mempool_setfreemax(isc_mempool_t *mpctx, unsigned int limit) {
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->freemax = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		mpctx->freemax = limit;
+	}
 }
 
 unsigned int
@@ -1683,13 +1631,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	freemax = mpctx->freemax;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		freemax = mpctx->freemax;
+	}
 
 	return (freemax);
 }
@@ -1700,13 +1644,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	freecount = mpctx->freecount;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		freecount = mpctx->freecount;
+	}
 
 	return (freecount);
 }
@@ -1717,13 +1657,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->maxalloc = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		mpctx->maxalloc = limit;
+	}
 }
 
 unsigned int
@@ -1732,13 +1668,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	maxalloc = mpctx->maxalloc;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		maxalloc = mpctx->maxalloc;
+	}
 
 	return (maxalloc);
 }
@@ -1749,13 +1681,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	allocated = mpctx->allocated;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		allocated = mpctx->allocated;
+	}
 
 	return (allocated);
 }
@@ -1765,13 +1693,9 @@
 	REQUIRE(limit > 0);
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	mpctx->fillcount = limit;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		mpctx->fillcount = limit;
+	}
 }
 
 unsigned int
@@ -1780,13 +1704,9 @@
 
 	REQUIRE(VALID_MEMPOOL(mpctx));
 
-	if (mpctx->lock != NULL)
-		LOCK(mpctx->lock);
-
-	fillcount = mpctx->fillcount;
-
-	if (mpctx->lock != NULL)
-		UNLOCK(mpctx->lock);
+	__tm_atomic {
+		fillcount = mpctx->fillcount;
+	}
 
 	return (fillcount);
 }
