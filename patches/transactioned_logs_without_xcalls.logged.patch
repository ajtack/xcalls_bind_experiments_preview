diff -Naur -x '*.i' -x '*~' -x make -x '*.log' -x doc -x contrib -x tests -x config.h -x config.status -x isc-config.h -x '*.kdev*' -x platform.h -x netdb.h -x Doxyfile -x 'port_*.h' bind-9.3.5-P2/lib/isc/log.c changed/lib/isc/log.c
--- bind-9.3.5-P2/lib/isc/log.c	2006-03-01 18:37:20.000000000 -0600
+++ changed/lib/isc/log.c	2008-10-22 13:08:24.000000000 -0500
@@ -41,6 +41,8 @@
 #include <isc/time.h>
 #include <isc/util.h>
 
+#include <txc.h>
+
 #define LCTX_MAGIC		ISC_MAGIC('L', 'c', 't', 'x')
 #define VALID_CONTEXT(lctx)	ISC_MAGIC_VALID(lctx, LCTX_MAGIC)
 
@@ -149,7 +151,6 @@
 	isc_logmodule_t *		modules;
 	unsigned int			module_count;
 	int				debug_level;
-	isc_mutex_t			lock;
 	/* Locked by isc_log lock. */
 	isc_logconfig_t * 		logconfig;
 	char 				buffer[LOG_BUFFER_SIZE];
@@ -280,8 +281,6 @@
 
 		ISC_LIST_INIT(lctx->messages);
 
-		RUNTIME_CHECK(isc_mutex_init(&lctx->lock) == ISC_R_SUCCESS);
-
 		/*
 		 * Normally setting the magic number is the last step done
 		 * in a creation function, but a valid log context is needed
@@ -437,12 +436,10 @@
 	if (result != ISC_R_SUCCESS)
 		return (result);
 
-	LOCK(&lctx->lock);
-
-	old_cfg = lctx->logconfig;
-	lctx->logconfig = lcfg;
-
-	UNLOCK(&lctx->lock);
+	__tm_atomic {
+		old_cfg = lctx->logconfig;
+		lctx->logconfig = lcfg;
+	}
 
 	isc_logconfig_destroy(&old_cfg);
 
@@ -467,8 +464,6 @@
 		isc_logconfig_destroy(&lcfg);
 	}
 
-	DESTROYLOCK(&lctx->lock);
-
 	while ((message = ISC_LIST_HEAD(lctx->messages)) != NULL) {
 		ISC_LIST_UNLINK(lctx->messages, message, link);
 
@@ -947,23 +942,22 @@
 
 	REQUIRE(VALID_CONTEXT(lctx));
 
-	LOCK(&lctx->lock);
-
-	lctx->debug_level = level;
-	/*
-	 * Close ISC_LOG_DEBUGONLY channels if level is zero.
-	 */
-	if (lctx->debug_level == 0)
-		for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
-		     channel != NULL;
-		     channel = ISC_LIST_NEXT(channel, link))
-			if (channel->type == ISC_LOG_TOFILE &&
-			    (channel->flags & ISC_LOG_DEBUGONLY) != 0 &&
-			    FILE_STREAM(channel) != NULL) {
-				(void)fclose(FILE_STREAM(channel));
-				FILE_STREAM(channel) = NULL;
-			}
-	UNLOCK(&lctx->lock);
+	__tm_atomic {
+		lctx->debug_level = level;
+		/*
+		 * Close ISC_LOG_DEBUGONLY channels if level is zero.
+		 */
+		if (lctx->debug_level == 0)
+			for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
+			     channel != NULL;
+			     channel = ISC_LIST_NEXT(channel, link))
+				if (channel->type == ISC_LOG_TOFILE &&
+				    (channel->flags & ISC_LOG_DEBUGONLY) != 0 &&
+				    FILE_STREAM(channel) != NULL) {
+					(void)fclose(FILE_STREAM(channel));
+					FILE_STREAM(channel) = NULL;
+				}
+	}
 }
 
 unsigned int
@@ -1026,17 +1020,17 @@
 
 	REQUIRE(VALID_CONTEXT(lctx));
 
-	LOCK(&lctx->lock);
-	for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
-	     channel != NULL;
-	     channel = ISC_LIST_NEXT(channel, link))
+	__tm_atomic {
+		for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);
+		     channel != NULL;
+		     channel = ISC_LIST_NEXT(channel, link))
 
-		if (channel->type == ISC_LOG_TOFILE &&
-		    FILE_STREAM(channel) != NULL) {
-			(void)fclose(FILE_STREAM(channel));
-			FILE_STREAM(channel) = NULL;
-		}
-	UNLOCK(&lctx->lock);
+			if (channel->type == ISC_LOG_TOFILE &&
+			    FILE_STREAM(channel) != NULL) {
+				(void)fclose(FILE_STREAM(channel));
+				FILE_STREAM(channel) = NULL;
+			}
+	}
 }
 
 /****
@@ -1438,317 +1432,315 @@
 	time_string[0]  = '\0';
 	level_string[0] = '\0';
 
-	LOCK(&lctx->lock);
-
-	lctx->buffer[0] = '\0';
+	__tm_atomic {
+		lctx->buffer[0] = '\0';
 	
-	lcfg = lctx->logconfig;
+		lcfg = lctx->logconfig;
 
-	category_channels = ISC_LIST_HEAD(lcfg->channellists[category->id]);
+		category_channels = ISC_LIST_HEAD(lcfg->channellists[category->id]);
 
-	/*
-	 * XXXDCL add duplicate filtering? (To not write multiple times to
-	 * the same source via various channels).
-	 */
-	do {
 		/*
-		 * If the channel list end was reached and a match was made,
-		 * everything is finished.
+		 * XXXDCL add duplicate filtering? (To not write multiple times to
+		 * the same source via various channels).
 		 */
-		if (category_channels == NULL && matched)
-			break;
-
-		if (category_channels == NULL && ! matched &&
-		    category_channels != ISC_LIST_HEAD(lcfg->channellists[0]))
+		do {
 			/*
-			 * No category/module pair was explicitly configured.
-			 * Try the category named "default".
+			 * If the channel list end was reached and a match was made,
+			 * everything is finished.
 			 */
-			category_channels =
-				ISC_LIST_HEAD(lcfg->channellists[0]);
+			if (category_channels == NULL && matched)
+				break;
 
-		if (category_channels == NULL && ! matched)
-			/*
-			 * No matching module was explicitly configured
-			 * for the category named "default".  Use the internal
-			 * default channel.
-			 */
-			category_channels = &default_channel;
+			if (category_channels == NULL && ! matched &&
+			    category_channels != ISC_LIST_HEAD(lcfg->channellists[0]))
+				/*
+				 * No category/module pair was explicitly configured.
+				 * Try the category named "default".
+				 */
+				category_channels =
+					ISC_LIST_HEAD(lcfg->channellists[0]);
 
-		if (category_channels->module != NULL &&
-		    category_channels->module != module) {
-			category_channels = ISC_LIST_NEXT(category_channels,
-							  link);
-			continue;
-		}
+			if (category_channels == NULL && ! matched)
+				/*
+				 * No matching module was explicitly configured
+				 * for the category named "default".  Use the internal
+				 * default channel.
+				 */
+				category_channels = &default_channel;
 
-		matched = ISC_TRUE;
+			if (category_channels->module != NULL &&
+			    category_channels->module != module) {
+				category_channels = ISC_LIST_NEXT(category_channels,
+								  link);
+				continue;
+			}
 
-		channel = category_channels->channel;
-		category_channels = ISC_LIST_NEXT(category_channels, link);
+			matched = ISC_TRUE;
 
-		if (((channel->flags & ISC_LOG_DEBUGONLY) != 0) &&
-		    lctx->debug_level == 0)
-			continue;
+			channel = category_channels->channel;
+			category_channels = ISC_LIST_NEXT(category_channels, link);
 
-		if (channel->level == ISC_LOG_DYNAMIC) {
-			if (lctx->debug_level < level)
+			if (((channel->flags & ISC_LOG_DEBUGONLY) != 0) &&
+			    lctx->debug_level == 0)
 				continue;
-		} else if (channel->level < level)
-			continue;
 
-		if ((channel->flags & ISC_LOG_PRINTTIME) != 0 &&
-		    time_string[0] == '\0') {
-			isc_time_t isctime;
-			
-			TIME_NOW(&isctime);
-			isc_time_formattimestamp(&isctime, time_string,
-						 sizeof(time_string));
-		}
+			if (channel->level == ISC_LOG_DYNAMIC) {
+				if (lctx->debug_level < level)
+					continue;
+			} else if (channel->level < level)
+				continue;
 
-		if ((channel->flags & ISC_LOG_PRINTLEVEL) != 0 &&
-		    level_string[0] == '\0') {
-			if (level < ISC_LOG_CRITICAL)
-				snprintf(level_string, sizeof(level_string),
-					 isc_msgcat_get(isc_msgcat,
-						        ISC_MSGSET_LOG,
-						        ISC_MSG_LEVEL,
-						        "level %d: "),
-					 level);
-			else if (level > ISC_LOG_DYNAMIC)
-				snprintf(level_string, sizeof(level_string),
-					 "%s %d: ", log_level_strings[0],
-					 level);
-			else
-				snprintf(level_string, sizeof(level_string),
-					 "%s: ", log_level_strings[-level]);
-		}
+			if ((channel->flags & ISC_LOG_PRINTTIME) != 0 &&
+			    time_string[0] == '\0') {
+				isc_time_t isctime;
+			
+				TIME_NOW(&isctime);
+				isc_time_formattimestamp(&isctime, time_string,
+							 sizeof(time_string));
+			}
 
-		/*
-		 * Only format the message once.
-		 */
-		if (lctx->buffer[0] == '\0') {
-			(void)vsnprintf(lctx->buffer, sizeof(lctx->buffer),
-					iformat, args);
+			if ((channel->flags & ISC_LOG_PRINTLEVEL) != 0 &&
+			    level_string[0] == '\0') {
+				if (level < ISC_LOG_CRITICAL)
+					snprintf(level_string, sizeof(level_string),
+						 isc_msgcat_get(isc_msgcat,
+							        ISC_MSGSET_LOG,
+							        ISC_MSG_LEVEL,
+							        "level %d: "),
+						 level);
+				else if (level > ISC_LOG_DYNAMIC)
+					snprintf(level_string, sizeof(level_string),
+						 "%s %d: ", log_level_strings[0],
+						 level);
+				else
+					snprintf(level_string, sizeof(level_string),
+						 "%s: ", log_level_strings[-level]);
+			}
 
 			/*
-			 * Check for duplicates.
+			 * Only format the message once.
 			 */
-			if (write_once) {
-				isc_logmessage_t *message, *new;
-				isc_time_t oldest;
-				isc_interval_t interval;
-
-				isc_interval_set(&interval,
-						 lcfg->duplicate_interval, 0);
+			if (lctx->buffer[0] == '\0') {
+				(void)vsnprintf(lctx->buffer, sizeof(lctx->buffer),
+						iformat, args);
 
 				/*
-				 * 'oldest' is the age of the oldest messages
-				 * which fall within the duplicate_interval
-				 * range.
+				 * Check for duplicates.
 				 */
-				TIME_NOW(&oldest);
-				if (isc_time_subtract(&oldest, &interval, &oldest)
-				    != ISC_R_SUCCESS)
+				if (write_once) {
+					isc_logmessage_t *message, *new;
+					isc_time_t oldest;
+					isc_interval_t interval;
+
+					isc_interval_set(&interval,
+							 lcfg->duplicate_interval, 0);
+
 					/*
-					 * Can't effectively do the checking
-					 * without having a valid time.
+					 * 'oldest' is the age of the oldest messages
+					 * which fall within the duplicate_interval
+					 * range.
 					 */
-					message = NULL;
-				else
-					message =ISC_LIST_HEAD(lctx->messages);
-
-				while (message != NULL) {
-					if (isc_time_compare(&message->time,
-							     &oldest) < 0) {
+					TIME_NOW(&oldest);
+					if (isc_time_subtract(&oldest, &interval, &oldest)
+					    != ISC_R_SUCCESS)
 						/*
-						 * This message is older
-						 * than the duplicate_interval,
-						 * so it should be dropped from
-						 * the history.
-						 *
-						 * Setting the interval to be
-						 * to be longer will obviously
-						 * not cause the expired
-						 * message to spring back into
-						 * existence.
+						 * Can't effectively do the checking
+						 * without having a valid time.
 						 */
-						new = ISC_LIST_NEXT(message,
-								    link);
-
-						ISC_LIST_UNLINK(lctx->messages,
-								message, link);
+						message = NULL;
+					else
+						message =ISC_LIST_HEAD(lctx->messages);
+
+					while (message != NULL) {
+						if (isc_time_compare(&message->time,
+								     &oldest) < 0) {
+							/*
+							 * This message is older
+							 * than the duplicate_interval,
+							 * so it should be dropped from
+							 * the history.
+							 *
+							 * Setting the interval to be
+							 * to be longer will obviously
+							 * not cause the expired
+							 * message to spring back into
+							 * existence.
+							 */
+							new = ISC_LIST_NEXT(message,
+									    link);
+
+							ISC_LIST_UNLINK(lctx->messages,
+									message, link);
+
+							isc_mem_put(lctx->mctx,
+								message,
+								sizeof(*message) + 1 +
+								strlen(message->text));
+
+							message = new;
+							continue;
+						}
 
-						isc_mem_put(lctx->mctx,
-							message,
-							sizeof(*message) + 1 +
-							strlen(message->text));
+						/*
+						 * This message is in the duplicate
+						 * filtering interval ...
+						 */
+						if (strcmp(lctx->buffer, message->text)
+						    == 0) {
+							/*
+							 * ... and it is a duplicate.
+							 * Unlock the mutex and
+							 * get the hell out of Dodge.
+							 */
+							// UNLOCK(&lctx->lock);
+							return;
+						}
 
-						message = new;
-						continue;
+						message = ISC_LIST_NEXT(message, link);
 					}
 
 					/*
-					 * This message is in the duplicate
-					 * filtering interval ...
+					 * It wasn't in the duplicate interval,
+					 * so add it to the message list.
 					 */
-					if (strcmp(lctx->buffer, message->text)
-					    == 0) {
+					new = isc_mem_get(lctx->mctx,
+							  sizeof(isc_logmessage_t) +
+							  strlen(lctx->buffer) + 1);
+					if (new != NULL) {
 						/*
-						 * ... and it is a duplicate.
-						 * Unlock the mutex and
-						 * get the hell out of Dodge.
+						 * Put the text immediately after
+						 * the struct.  The strcpy is safe.
 						 */
-						UNLOCK(&lctx->lock);
-						return;
-					}
+						new->text = (char *)(new + 1);
+						strcpy(new->text, lctx->buffer);
 
-					message = ISC_LIST_NEXT(message, link);
-				}
+						TIME_NOW(&new->time);
 
-				/*
-				 * It wasn't in the duplicate interval,
-				 * so add it to the message list.
-				 */
-				new = isc_mem_get(lctx->mctx,
-						  sizeof(isc_logmessage_t) +
-						  strlen(lctx->buffer) + 1);
-				if (new != NULL) {
-					/*
-					 * Put the text immediately after
-					 * the struct.  The strcpy is safe.
-					 */
-					new->text = (char *)(new + 1);
-					strcpy(new->text, lctx->buffer);
-
-					TIME_NOW(&new->time);
-
-					ISC_LIST_APPEND(lctx->messages,
-							new, link);
+						ISC_LIST_APPEND(lctx->messages,
+								new, link);
+					}
 				}
 			}
-		}
 
-		printtime     = ISC_TF((channel->flags & ISC_LOG_PRINTTIME)
-				       != 0);
-		printtag      = ISC_TF((channel->flags & ISC_LOG_PRINTTAG)
-				       != 0 && lcfg->tag != NULL);
-		printcategory = ISC_TF((channel->flags & ISC_LOG_PRINTCATEGORY)
-				       != 0);
-		printmodule   = ISC_TF((channel->flags & ISC_LOG_PRINTMODULE)
-				       != 0);
-		printlevel    = ISC_TF((channel->flags & ISC_LOG_PRINTLEVEL)
-				       != 0);
-
-		switch (channel->type) {
-		case ISC_LOG_TOFILE:
-			if (FILE_MAXREACHED(channel)) {
-				/*
-				 * If the file can be rolled, OR
-				 * If the file no longer exists, OR
-				 * If the file is less than the maximum size,
-				 *    (such as if it had been renamed and
-				 *     a new one touched, or it was truncated
-				 *     in place)
-				 * ... then close it to trigger reopening.
-				 */
-				if (FILE_VERSIONS(channel) !=
-				    ISC_LOG_ROLLNEVER ||
-				    (stat(FILE_NAME(channel), &statbuf) != 0 &&
-				     errno == ENOENT) ||
-				    statbuf.st_size < FILE_MAXSIZE(channel)) {
-					(void)fclose(FILE_STREAM(channel));
-					FILE_STREAM(channel) = NULL;
-					FILE_MAXREACHED(channel) = ISC_FALSE;
-				} else
+			printtime     = ISC_TF((channel->flags & ISC_LOG_PRINTTIME)
+					       != 0);
+			printtag      = ISC_TF((channel->flags & ISC_LOG_PRINTTAG)
+					       != 0 && lcfg->tag != NULL);
+			printcategory = ISC_TF((channel->flags & ISC_LOG_PRINTCATEGORY)
+					       != 0);
+			printmodule   = ISC_TF((channel->flags & ISC_LOG_PRINTMODULE)
+					       != 0);
+			printlevel    = ISC_TF((channel->flags & ISC_LOG_PRINTLEVEL)
+					       != 0);
+
+			switch (channel->type) {
+			case ISC_LOG_TOFILE:
+				if (FILE_MAXREACHED(channel)) {
 					/*
-					 * Eh, skip it.
+					 * If the file can be rolled, OR
+					 * If the file no longer exists, OR
+					 * If the file is less than the maximum size,
+					 *    (such as if it had been renamed and
+					 *     a new one touched, or it was truncated
+					 *     in place)
+					 * ... then close it to trigger reopening.
 					 */
-					break;
-			}
-
-			if (FILE_STREAM(channel) == NULL) {
-				result = isc_log_open(channel);
-				if (result != ISC_R_SUCCESS &&
-				    result != ISC_R_MAXSIZE &&
-				    (channel->flags & ISC_LOG_OPENERR) == 0) {
-					syslog(LOG_ERR,
-					       "isc_log_open '%s' failed: %s",
-					       FILE_NAME(channel),
-					       isc_result_totext(result));
-					channel->flags |= ISC_LOG_OPENERR;
+					if (FILE_VERSIONS(channel) !=
+					    ISC_LOG_ROLLNEVER ||
+					    (stat(FILE_NAME(channel), &statbuf) != 0 &&
+					     errno == ENOENT) ||
+					    statbuf.st_size < FILE_MAXSIZE(channel)) {
+						(void)fclose(FILE_STREAM(channel));
+						FILE_STREAM(channel) = NULL;
+						FILE_MAXREACHED(channel) = ISC_FALSE;
+					} else
+						/*
+						 * Eh, skip it.
+						 */
+						break;
 				}
-				if (result != ISC_R_SUCCESS)
-					break;
-				channel->flags &= ~ISC_LOG_OPENERR;
-			}
-			/* FALLTHROUGH */
 
-		case ISC_LOG_TOFILEDESC:
-			fprintf(FILE_STREAM(channel), "%s%s%s%s%s%s%s%s%s%s\n",
-				printtime     ? time_string	: "",
-				printtime     ? " "		: "",
-				printtag      ? lcfg->tag	: "",
-				printtag      ? ": "		: "",
-				printcategory ? category->name	: "",
-				printcategory ? ": "		: "",
-				printmodule   ? (module != NULL ? module->name
-						 		: "no_module")
-					      			: "",
-				printmodule   ? ": "		: "",
-				printlevel    ? level_string	: "",
-				lctx->buffer);
+				if (FILE_STREAM(channel) == NULL) {
+					result = isc_log_open(channel);
+					if (result != ISC_R_SUCCESS &&
+					    result != ISC_R_MAXSIZE &&
+					    (channel->flags & ISC_LOG_OPENERR) == 0) {
+						syslog(LOG_ERR,
+						       "isc_log_open '%s' failed: %s",
+						       FILE_NAME(channel),
+						       isc_result_totext(result));
+						channel->flags |= ISC_LOG_OPENERR;
+					}
+					if (result != ISC_R_SUCCESS)
+						break;
+					channel->flags &= ~ISC_LOG_OPENERR;
+				}
+				/* FALLTHROUGH */
 
-			fflush(FILE_STREAM(channel));
+			case ISC_LOG_TOFILEDESC:
+				fprintf(FILE_STREAM(channel), "%s%s%s%s%s%s%s%s%s%s\n",
+					printtime     ? time_string	: "",
+					printtime     ? " "		: "",
+					printtag      ? lcfg->tag	: "",
+					printtag      ? ": "		: "",
+					printcategory ? category->name	: "",
+					printcategory ? ": "		: "",
+					printmodule   ? (module != NULL ? module->name
+							 		: "no_module")
+						      			: "",
+					printmodule   ? ": "		: "",
+					printlevel    ? level_string	: "",
+					lctx->buffer);
 
-			/*
-			 * If the file now exceeds its maximum size
-			 * threshold, note it so that it will not be logged
-			 * to any more.
-			 */
-			if (FILE_MAXSIZE(channel) > 0) {
-				INSIST(channel->type == ISC_LOG_TOFILE);
+				fflush(FILE_STREAM(channel));
 
-				/* XXXDCL NT fstat/fileno */
-				/* XXXDCL complain if fstat fails? */
-				if (fstat(fileno(FILE_STREAM(channel)),
-					  &statbuf) >= 0 &&
-				    statbuf.st_size > FILE_MAXSIZE(channel))
-					FILE_MAXREACHED(channel) = ISC_TRUE;
-			}
+				/*
+				 * If the file now exceeds its maximum size
+				 * threshold, note it so that it will not be logged
+				 * to any more.
+				 */
+				if (FILE_MAXSIZE(channel) > 0) {
+					INSIST(channel->type == ISC_LOG_TOFILE);
 
-			break;
+					/* XXXDCL NT fstat/fileno */
+					/* XXXDCL complain if fstat fails? */
+					if (fstat(fileno(FILE_STREAM(channel)),
+						  &statbuf) >= 0 &&
+					    statbuf.st_size > FILE_MAXSIZE(channel))
+						FILE_MAXREACHED(channel) = ISC_TRUE;
+				}
 
-		case ISC_LOG_TOSYSLOG:
-			if (level > 0)
-				syslog_level = LOG_DEBUG;
-			else if (level < ISC_LOG_CRITICAL)
-				syslog_level = LOG_CRIT;
-			else
-				syslog_level = syslog_map[-level];
+				break;
 
-			(void)syslog(FACILITY(channel) | syslog_level,
-			       "%s%s%s%s%s%s%s%s%s%s",
-			       printtime     ? time_string	: "",
-			       printtime     ? " "		: "",
-			       printtag      ? lcfg->tag	: "",
-			       printtag      ? ": "		: "",
-			       printcategory ? category->name	: "",
-			       printcategory ? ": "		: "",
-			       printmodule   ? (module != NULL	? module->name
-						 		: "no_module")
-					      			: "",
-			       printmodule   ? ": "		: "",
-			       printlevel    ? level_string	: "",
-			       lctx->buffer);
-			break;
+			case ISC_LOG_TOSYSLOG:
+				if (level > 0)
+					syslog_level = LOG_DEBUG;
+				else if (level < ISC_LOG_CRITICAL)
+					syslog_level = LOG_CRIT;
+				else
+					syslog_level = syslog_map[-level];
 
-		case ISC_LOG_TONULL:
-			break;
+				(void)syslog(FACILITY(channel) | syslog_level,
+				       "%s%s%s%s%s%s%s%s%s%s",
+				       printtime     ? time_string	: "",
+				       printtime     ? " "		: "",
+				       printtag      ? lcfg->tag	: "",
+				       printtag      ? ": "		: "",
+				       printcategory ? category->name	: "",
+				       printcategory ? ": "		: "",
+				       printmodule   ? (module != NULL	? module->name
+							 		: "no_module")
+						      			: "",
+				       printmodule   ? ": "		: "",
+				       printlevel    ? level_string	: "",
+				       lctx->buffer);
+				break;
 
-		}
+			case ISC_LOG_TONULL:
+				break;
 
-	} while (1);
+			}
 
-	UNLOCK(&lctx->lock);
+		} while (1);
+	}
 }
